<!doctype html public "-//IETF//DTD HTML//EN//2.0">
<html><head>
<title>PIA InterForm Manual</title>
<link rev="made" href="mailto:steve@crc.ricoh.com"></link>
</head><body>
<h1>PIA InterForm Manual</h1>

<blockquote><em>
  This document is a user's manual for the Platform for Information
  Appliances' InterForm (Interactive/Interpreted.Interface Form) markup
  language.  It is 
  an ordinary HTML document, but if you are viewing it through a PIA you will
  be able to use links to an <em>active</em> document, the <a
  href="/InterForm/home.if">InterForm Demonstration Agent</a>.  Other
  information of interest to Agent authors can be found in the <a
  href="../Author/index.html">Agent Author's Manual</a>.
</em></blockquote>

<h3>Related Documents:</h3>

<ul>
  <li> <a href="../Author/index.html">Agent Author's Manual</a>
  <li> <a href="Tagset/basic.html">Basic (Primitive) Tagset Manual</a>
  <li> <a href="Tagset/xxml.html">eXtended XML (XXML) Tagset Manual</a>
  <li> <a href="Tagset/xhtml.html">eXtended HTML (XHTML) Tagset Manual</a>
  <li> <a href="Tagset/pia-xhtml.html">PIA XHTML Tagset Manual</a>
       <p>
  <li> <a href="/InterForm/home.if">InterForm Demonstration Agent</a> (from PIA
       only)
  <li> <a href="/Agency/entities.if">Entities</a> (from PIA only)
  <li> <a href="/Agency/actors.if">Actors</a> (from PIA only)
  <li> <a href="/InterForm/tag_man.if">legacy tagset</a>
  <li> <a href="/InterForm/demo.if">legacy Examples</a>
</ul>

<h3>Contents:</h3>

<ul>
  <li> <a href="#intro">Introduction</a>
  <li> <a href="#interp">The InterForm Interpretor</a>
  <li> <a href="#tagsets">Tagsets</a> (
       <a href="Tagset">Tagset Manuals</a> )
  <li> <a href="#invoke">Program Invocation</a>
</ul>

<hr>
<h2><a name="intro">Introduction:  What is an InterForm?</a></h2>

An InterForm is a HTML document that contains some tags that a PIA can
``interpret.''  You can think of an InterForm as an HTML form that doesn't
need a corresponding CGI script to handle it.  You can also think of it as
an ``active'' document that is run through a special-purpose formatter.<p>

Because the extra tags follow strict SGML syntax conventions, InterForms can
be edited with any text editor, or any HTML editor that lets you use new or
non-standard tags, or any SGML editor (at least when we create an extended
DTD).<p> 

We hope that authors will find InterForms to be as easy to use as
word-processor macros or text-formatting style sheets.  Programmers will find
that, in spite of their unfamiliar syntax, InterForms have all the power of
any modern object-based language.<p>

<h3><a name=file_ext>InterForm Filename Extensions</a></h3>


As in most document-processing systems, the default file type of an InterForm
is indicated by its ``extension'' -- the characters its name following the
last period character.  The defined extensions are:

<dl compact>
  <dt> .xh
  <dd> ``eXtended-HTML'' -- resulting in a MIME type of
     <code>text/html</code> 
  <dt> .xx 
  <dd> ``eXtended-XML'' -- resulting in a MIME type appropriate for XML.
  <dt> .lif
  <dd> ``legacy'' InterForm processed with the new DPS using a tagset largely
       compatible with the old interpretor.  Since the legacy tagset is
       incomplete, these won't work in all cases.  [Soon to be obsolete. ]
  <dt> .if
  <dd> InterForm processed with the <em>old</em> interpretor.  [Soon to be
       obsolete. ]
</dl>


<h3>InterForm Data Structures</h3>

The key idea behind InterForms is <em>computing with documents</em>, so data
in the InterForm system is simply a piece of a document.  Markup is explicitly
included in this, and HTML ``data structures'' are used as much as
possible.<p>

In particular, HTML lists (&lt;ul&gt; and &lt;ol&gt;) are used as lists or
arrays.  Definition Lists (&lt;dl&gt;) are used as ``associative arrays,''
in which you can look up a ``term'' (&lt;dt&gt;) and get the corresponding
data (&lt;dd&gt;).  Similarly, tables (&lt;table&gt;) can be used like
database tables.   This makes it easy to take parts of documents and use them
as data, something most existing systems are not very good at.<p>

In general, all data in an InterForm is in the form of SGML
``<dfn>content</dfn>'', consisting of ordinary ``<dfn>text</dfn>,''
``<dfn>entities</dfn>,'' and ``<dfn>elements</dfn>.''  An element is a
compound object consisting of a <em>start tag</em> and <em>end tag</em>
enclosing some <em>content</em> elements between them.  The element may also
have some named <dfn>attributes</dfn>; attributes and their associated values
appear in the element's start tag.<p>

Elements are also referred to as <dfn>markup</dfn>.  Some operations let you
operate only on text or markup.  Markup can be added (for example, by
converting a sequence of words into a list), or removed.  (Entities are
neither text nor markup; they are actually ``containers'' that may contain
any kind of content.<p>

<h3>Entities</h3>

Entities (those things like <code>&amp;copy;</code> that a browser displays as
special characters) are used as variables or macros--they can be defined (and
redefined) and later ``expanded'' (replaced by their definition).  As you
might expect, a definition list can be used for this.  Entities can also be
used as ``iteration variables''--you can repeat a piece of text for every item
in a list, with the <code>&amp;li;</code> entity replaced by each list item in
turn.<p>

<h3>Actions and Tagsets</h3>

Finally, ``<dfn>actions</dfn>'' can be associated with ``active'' elements.
Whenever such an element appears in a document, a corresponding piece of
InterForm code called its ``<dfn>action</dfn>'' is ``<dfn>expanded</dfn>,''
with locally-defined entities bound to the element's attributes and content.
An active element is sometimes called an ``<dfn>actor</dfn>'' in older
documentation. <p>

A collection of entities and elements designed to work together in an active
document is called a ``<dfn>tagset</dfn>,'' largely for historical reasons
(MetaHTML also uses ``tagset'' in this sense.)  A tagset is essentially an
extension of an SGML or XML <dfn>Document Type Definition</dfn> (DTD),
although tagsets are usually defined using an XML-based notation which is
easier to parse and to extend. <p>

The PIA defines a standard tagset, called <code>pia-xhtm</code> for use in
InterForms.  Some agents may 
define special tagsets as extensions to the standard one.  Completely
different tagsets can also be defined for different kinds of document
processing: parsing HTML, formatting, even translating SGML documents with
other document types <em>into</em> HTML.<p>

Complete documentation for the tagsets can be found <a
href="#tagsets">below.</a> 

<hr>
<h2><a name="interp">The InterForm Interpretor</a></h2>

<strong>The InterForm language and its interpretor have undergone major
changes, and the documentation is not yet up to date.  The new interpretor can
be found in <a
href="../../../src/java/crc/dps/"><code>../../../src/java/crc/dps/</code></a>
and its subdirectories; JavaDoc documentation will be in the <a
href="../Api/index.html">API Manual</a> if it has been built. </strong> <p>

<h3>Overview</h3>

At this point, astute readers with writing experience will recognize actors
and entities as special kinds of ``macros'' and ``abbreviations,'' and would
suspect that processing an InterForm file involves running it through a kind
of formatting or typesetting engine.  Readers with programming experience
might instead choose to regard them as ``functions'' and ``variables,'' and
expect to find a kind of interpretor.  Both would be perfectly correct.<p>

The Document Processing System (DPS) operates almost exactly like any other
SGML text-processing application.  It takes in a stream of characters from a
file, an HTTP server, or an input device and splits it into a stream of
``<dfn>tokens</dfn>.''  Each token is either ``<dfn>text</dfn>'' (a string of
ordinary characters), an entity name, or a piece of ``<dfn>markup</dfn>'' -- a
start tag, end tag, or SGML declaration.  The tagset is consulted to determine
the syntax of each element, and to locate any associated actions. <p>

This splitting and identifying is called ``<dfn>parsing</dfn>'', and in most
systems results in a data structure called a ``<dfn>parse tree</dfn>'' -- a
hierarchical collection of objects called ``<dfn>nodes</dfn>.''  These nodes
are described further in the <a href="http://www.w3.org/">World Wide Web
Consortium</a>'s <a href="http://www.w3.org/DOM/">Document Object Model</a>.
<p>

The InterForm DPS is not exactly typical.  Instead of actually building a
parse tree, the Parser looks like a tree <em>traverser</em> -- an object that
marks a position in a tree, and can be commanded to travel to the next node in
a tree, or up or down a level.  It can provide information about the current
node or any of its direct ancestors, but not about the <em>children</em> of
the current node -- these can only be inspected by moving the traverser down a
level.  This means that the DPS can process documents that are too large to
fit in the computer's memory all at once.<p>

The DPS ``<dfn>Processor</dfn>'' takes nodes from an ``<dfn>Input</dfn>''
object (typically a Parser) and performs the action associated with each node
it encounters.  The default, if no action is specified, is to simply copy the
node to the Processor's ``<dfn>Output</dfn>'', performing any specified
processing on its children along the way.

The Output is essentially a tree <em>constructor</em> for parse trees, except
that instead of constructing an actual data structure it might instead convert
nodes back into characters and send them to an output stream, usually attached
to a user's Web browser.<p>

Because of the way processing is done, almost all operations on a document are
essentially ``local'' -- expanding an active element has no effect on anything
<em>outside</em> that element; it will simply replace it with a (possibly
empty) sequence of content nodes. <p>

The only exception to this locality rule comes about because of the
&lt;define&gt; and &lt;set&gt; elements; these permit entities and active
elements to be defined (and redefined), and so can have an effect on
expansions that occur later in the document.  This can make active documents
hard to read, so &lt;define&gt; and &lt;set&gt; should be used very
sparingly other than at the very beginning of a document.  <p>


<h3>Terminology</h3>

Replacing an active element or entity with new data is called
``<dfn>expanding</dfn>'' it, because it often (not always) gets bigger as a
result.<p>

Performing an action on its corresponding element is often called
``<dfn>applying</dfn>'' the action to the element.<p>

Associating an entity or attribute name with a value is called
``<dfn>binding</dfn>'' the name to the value.  A value may be anything from a
single character to an entire document with markup.<p>

Parsing an incoming character stream, expanding entities, applying actions,
and putting them into an output stream is called ``<dfn>processing</dfn>.''
<p>


<hr>
<h2>The InterForm Language</h2>

<h3>Syntax</h3>

The syntax of the InterForm language is basically that of HTML; more
specifically it is derived from the SGML reference syntax, which it follows
<em>exactly</em>.  Any InterForm can be parsed using an SGML parser (with an
appropriate Document Type Definition).  Most HTML editors can handle
InterForms; all that is needed is the ability to enter non-standard entities
and element tags.  HTML editors can do this because companies like Netscape
and Microsoft keep adding tags faster than the editor vendors can keep up.  An
SGML validator, with an appropriate DTD (document type definition) can be used
to validate the syntactic structure of an InterForm.<p>

<h3>Names</h3>

There are two, slightly different kinds of names (identifiers) in the
InterForm system.  Element tags and attributes start with a letter and contain
any sequence of letters, digits, ``<code>.</code>'' (period),
``<code>-</code>'' (hyphen) ``<code>_</code>'' (underscore), and
``<code>:</code>'' (colon) characters.  Case is ignored in HTML, but
significant in XML.  Entities come from the same character set, but case is
<em>always</em> significant (the original reason being to make it easy to
represent upper- and lower-case letters in foreign alphabets).<p>

The practical effect of the case-sensitivity rules is that you can use case to
distinguish entities, where it matters.  On the other hand, you can use case
to improve the readability of different kinds of tags and attributes, for
example to distinguish betweem ordinary HTML tags and attributes, which can be
in any case, and the special <em>active</em> tags and their attributes, which
are always lowercase (because they're basically XML).  You can use UPPERCASE
or MixedCase for your own active tags and be certain that there will never be
a system tag that conflicts. <p>

URL's and filenames have their own sets of rules, of course, and filenames
differ from one operating system to another.  Other names may refer to
environment variables and software objects in the PIA (agents, for example);
these names are usually case sensitive. <p>

Within entity names and active element tag names, ``<code>-</code>'' (hyphen)
is usually used to separate words.  The ``<code>:</code>'' (colon) character
is special: the portion of the name before the colon designates a
``<dfn>namespace</dfn>,'' and the portion after it a name <em>within</em> that
space.  Each user-defined active element, for example, defines a namespace
with the element's tag name as its namespace name, and the names
<code>attributes</code> and <code>content</code> defined within it. <p>

Many actors accept a large variety of special attributes that modify their
behavior; for example ``<code>&lt;test zero&gt;</code>'' and
``<code>&lt;numeric sort&gt;</code>''.  Some, notably <code>&lt;if&gt;</code>,
<code>&lt;select&gt;</code> and <code>&lt;repeat&gt;</code> also have
specialized ``sub-elements'' that are used noplace else (for example,
<code>&lt;then&gt;</code> and <code>&lt;else&gt;</code> inside
<code>&lt;if&gt;</code>).  <p>


<h3>Entities</h3>

<dl>
  <dt> entity ::= '&amp;' name ';'
  <dd> 
  <dt> name ::= [identifier ':']? identifier
  <dd> 
  <dt> identifier := [letter | digit | '-' | '_' | '.']+
  <dd> 
</dl>

An entity reference consists of the character ``<code>&amp;</code>''
(ampersand) followed by a name, followed by the character ``<code>;</code>''
(semicolon).  The semicolon is always required.  Case is <em>significant</em>
in entity names.  <p>

An entity name may consist of a pair of sub-names separated by
``<code>:</code>'' (period).  These sub-names form a path (similar to a file
path) through a sequence of ``namespaces''.  If no namespace is given, the
interpretor will search through any locally-defined entities (for example, the
list element entity defined by the &lt;repeat&gt; tag) and the top-level
(global) entity table associated with the InterForm being interpreted.
<p>

<strong>The InterForm language and its interpretor have undergone major
changes, and the documentation is not yet up to date.  The new interpretor can
be found in <a
href="../../../src/java/crc/dps/"><code>../../../src/java/crc/dps/</code></a>
and its subdirectories; JavaDoc documentation will be in the <a
href="../Api/index.html">API Manual</a> if it has been built.  The namespaces
and entities mentioned below may change as a result. </strong> <p>

The following entities are pre-defined in the PIA:<p>

<dl>

  <dt> <b><a name="e-agentName">agentName</a></b>
  <dd> The name of the agent that owns this InterForm
  <dt> <b><a name="e-agentNames">agentNames</a></b>
  <dd> The names of all defined agents.
  <dt> <b><a name="e-agentPath">agentPath</a></b>
  <dd> The full path to this agent (i.e. ``/Type/Name'' if agentName and
       agentType are different.
  <dt> <b><a name="e-agentType">agentType</a></b>
  <dd> The type of the agent that owns this InterForm
  <dt> <b><a name="e-date">date</a></b>
  <dd> The current date in the form <code>yyyymmdd</code>.  This format is an
       ISO standard; dates in this format can be sorted, and are valid as
       filenames, SGML identifiers, table keys, and so on.
  <dt> <b><a name="e-dateString">dateString</a></b>
  <dd> The current date and time in a human-readable form similar to that
       generated by the Unix <code>date</code> command.
  <dt> <b><a name="e-day">day</a></b>
  <dd> The current day of the month, padded with a zero if necessary to make
       two digits.
  <dt> <b><a name="e-dayName">dayName</a></b>
  <dd> The name of the current day of the week.
  <dt> <b><a name="e-entityNames">entityNames</a></b>
  <dd> The names of all defined entities.
  <dt> <b><a name="e-fileName">fileName</a></b>
  <dd> The name of the file containing the InterForm being expanded.
  <dt> <b><a name="e-filePath">filePath</a></b>
  <dd> The complete path to the file containing the InterForm being expanded.
       This is always a complete pathname on the system running the PIA.
  <dt> <b><a name="e-forms">forms</a></b>
  <dd> A counter that is incremented at the end tag of every &lt;form&gt;
       element.  Can be used for constructing a unique identifier for each
       form in a document.
  <dt> <b><a name="e-hour">hour</a></b>
  <dd> The current hour, padded with a zero if necessary to make
       two digits.
  <dt> <b><a name="e-minute">minute</a></b>
  <dd> The current minute, padded with a zero if necessary to make
       two digits.
  <dt> <b><a name="e-month">month</a></b>
  <dd> The current month (starting with January = 1), padded with a zero if
       necessary to make two digits.
  <dt> <b><a name="e-monthName">monthName</a></b>
  <dd> The name of the current month.
  <dt> <b><a name="e-piaDIR">piaDIR</a></b>
  <dd> The full pathname of the directory in which the PIA is installed.
       Normally accessed inside the PIA as <code><a
       href="/PIA/">/PIA/</a></code>.
  <dt> <b><a name="e-piaHOME">piaHOME</a></b>
  <dd> The home directory of the user executing the PIA
  <dt> <b><a name="e-piaHOST">piaHOST</a></b>
  <dd> The fully-qualified domain name of the host on which the PIA is
       executing. 
  <dt> <b><a name="e-piaPORT">piaPORT</a></b>
  <dd> The number of the port on which the PIA is listening for connections.
  <dt> <b><a name="e-piaUSER">piaUSER</a></b>
  <dd> The login name of the user executing the PIA.
  <dt> <b><a name="e-second">second</a></b>
  <dd> The current second, padded with a zero if necessary to make
       two digits.
  <dt> <b><a name="e-time">time</a></b>
  <dd> The current time in the form <code>hh:mm</code>
  <dt> <b><a name="e-transAgentName">transAgentName</a></b>
  <dd> The name of the agent (if any) to which the current request transaction
       is directed, or which generated the current response transaction.
  <dt> <b><a name="e-transAgentType">transAgentType</a></b>
  <dd> The type of the agent (if any) to which the current request transaction
       is directed, or which generated the current response transaction.
  <dt> <b><a name="e-url">url</a></b>
  <dd> The full URL of the current transaction.
  <dt> <b><a name="e-urlPath">urlPath</a></b>
  <dd> The path part of the current transaction's URL.
  <dt> <b><a name="e-urlQuery">urlQuery</a></b>
  <dd> The query string of the current transaction's URL.
  <dt> <b><a name="e-usrDIR">usrDIR</a></b>
  <dd> The full pathname of the directory that contains the user's personal
       PIA state.  Normally accessed inside the PIA as <code><a
       href="/My/">/My/</a></code>.
  <dt> <b><a name="e-weekday">weekday</a></b>
  <dd> The index (Sunday = 0) of the current day of the week.
  <dt> <b><a name="e-year">year</a></b>
  <dd> The current (four-digit) year.  This may be inaccurate if the PIA is
       executed with the system's date set before 1970.  On the other hand it
       may be correct.
</dl>

A complete list can be obtained from the PIA via the <a
href="/Agency/entities.if">/Agency/entities.if</a> InterForm.<p>

The following namespaces are defined:

<dl>
  <dt> <code>AGENT</code>
  <dd> The ``options'' of the PIA agent that owns the InterForm being expanded.
  <dt> <code>TRANS</code>
  <dd> The headers and features of the current transaction.  Defining a new
       entity in this namespace will assert a feature if the feature's name is
       lowercase, and a header if the name is capitalized.
  <dt> <code>LOCAL</code>
  <dd> The local namespace associated with the innermost element that contains
       the entity being expanded.  A new namespace is created if necessary.
  <dt> <code>GLOBAL</code>
  <dd> The namespace associated with the document.  Note that this namespace
       is actually a feature of the document's transaction, and so can be used
       for communication between agents. 
  <dt> <code>FORM</code>
  <dd> The query string or form content associated with a GET or POST query.
</dl>

If a path ends with a namespace, it is returned as a description list or query
string, depending on the context.

<h3>Elements</h3>

The syntax of an Element is:

<dl>
  <dt> element ::= start-tag [content end-tag] | empty-tag
  <dd> (An element that consists only of a start tag is called <em>empty</em>;
       empty elements are distinguished by their tags.
  <dt> start-tag ::= '<' tag [attribute]* '>'
  <dd> 
  <dt> end-tag ::= '</' tag '>' 
  <dd> 
  <dt> empty-tag ::= '<' tag [attribute]* '/>'
  <dd> 
  <dt> content ::= [text | element]*
  <dd> 
  <dt> tag ::= identifier
  <dd> 
  <dt> attribute ::= identifier ['=' value]
  <dd> (No spaces are permitted on either side of the '='.)
  <dt> value ::= identifier | nonblank* | quoted-string
  <dd> 
  <dt> quoted-string ::= quote non-quote* quote
  <dd> 
  <dt> quote := '"' | "'"
  <dd> 
  <dt> identifier ::= [ letter | digit | '-' | '.' ]+
  <dd> 
  <dt> nonblank ::= <em>any character except</em> '"' | "'" | '<' | '>' |
       whitespace 
  <dd> 
  <dt> whitespace ::= <em>any character with code &lt;= ' '.</em>
  <dd> 
</dl>

HTML tags do not contain '-', '.', or '_' characters.  Normally in the
InterForm language '-' is used to separate words in a single identifier, and
the other special characters are not used.  Namespaces (designated by a
namespace identifier followed by a colon) are not currently used for tags.
<p>

The order of attributes in a start tag is retained, but is not significant for
any of the predefined actors (or for any of the standard HTML tags, for that
matter).  The usual convention is to list the attributes in whatever order
makes the tag easiest to read. <p>

Strictly speaking, the form of attribute value consisting of nonblank
characters is incorrect.  It can make it hard to distinguish the final
`<code>/</code>' character that marks an XML empty tag, with odd results but
no error message.  <p>

<blockquote><em>
  Eventually we need to make certain parser parameters, such as whether to
  accept XML empty-tag delimiters or loosely-specified nonblank attribute
  values, options that can be set in the tagset.
</em></blockquote>

<h3>Lists</h3>

Several actors (for example, &lt;foreach&gt; and &lt;select&gt;) operate on
lists: sequences of ``items'' usually represented by the &lt;li&gt; element.
Lists function very much like <em>arrays</em> in conventional programming
languages, or <em>sets</em> in database languages.<p>

The following elements are treated as simple lists:
<blockquote>
  &lt;ul&gt;, &lt;ol&gt;, &lt;table&gt;, &lt;tr&gt;
</blockquote>

Note that a &lt;table&gt; is therefore a list of lists.  In addition, a
description list (&lt;dl&gt;) can be treated as a list of two-element
(&lt;dt&gt;, &lt;dd&gt;) lists, or as a simple, flat list of alternating names
and values.<p>

A text string, especially an attribute, is turned into a list by splitting it
on whitespace.  Whitespace between list item elements is ignored. <p> 

<em>Any</em> sequence of nodes can be treated as a list, by splitting
it either on whitespace, or on token boundaries.<p>


<h3>Associations</h3>

The following elements can be treated as <em>key</em>=<em>value</em>
associations:

<blockquote>
  &lt;dt&gt;, &lt;table&gt;
</blockquote>

The key in a table is normally just the first item in the row, but rows with a
blank first element (normally a &lt;th&gt;) are appended to the previous
row.  Tables with labeled columns (usually indicated by an initial row of
&lt;th&gt; elements) can be turned into <em>lists</em> of associations.<p>

In addition, any string in the proper form can be used; pairs can be separated
by whitespace or ``<code>&amp;</code>'' characters (as in query strings);
names and values are normally separated by an ``<code>=</code>'' character.<p>

Ordinary lists can be turned into associations by the &lt;associate&gt;
actor, which associates items in pairs.<p>

Any <em>element</em> can be turned into an association (of attributes and
values), optionally with its tag and content associated with special keys,
normally ``<code>-tag-</code>'' and ``<code>-content-</code>'', that cannot be
mistaken for attributes. This is also done using the the &lt;associate&gt;
actor.<p>

Sets of associations are found in conventional programming languages as hash
tables (AWK and Perl), association-lists (LISP), and tuples (relational
database languages).<p>


<h3>Tagsets</h3>

A <dfn>tagset</dfn> contains the definitions of the entities, elements and
attributes that can be used in a document, along with their values, associated
actions, and details of their syntax.  A tagset specifies a superset of the
information in a document's DTD (Document Type Definition), and is contained
in a file with a ``<code>.ts</code>'' extension. <p>

<strong>The InterForm language and its interpretor have undergone major
changes, and the documentation is not yet up to date.  Documentation for the
new tagsets can be found in the <a
href="Tagset"><code>Tagset</code></a> directory in files with lower-case
names. </strong> <p>


<h3>Actor Documentation</h3>

Every actor has some associated on-line documentation strings which can be
specified as attributes when the actor is defined (and eventually using
elements inside the actor's body).  These are:

<dl>
  <dt> <code>syntax</code>
  <dd> A regular-expression syntax description for the actor.
  <dt> <code>dscr</code>
  <dd> A narrative description of the actor's semantics.  Uppercase words in
       this description correspond to attributes of the element that invokes
       the actor.
  <dt> <code>note</code>
  <dd> Any additional information, in text form.
  <dt> <code>doc</code>
  <dd> Full documentation, usually in HTML form.
</dl>

The following actors are used to access an actor's documentation:

<dl>
  <dt> <code>&lt;actor-attrs name=<em>id</em>&gt;</code>
  <dd> The attributes of the actor, <em>except for the documentation
       attributes</em>, as specified in the <code>&lt;actor&gt;</code> element
       that defined the actor. 
  <dt> <code>&lt;actor-dscr name=<em>id</em>&gt;</code>
  <dd> The actor's description string.  <code>&lt;add-markup&gt;</code> can be
       used to convert capitalized names to boldface, and so on.
  <dt> <code>&lt;actor-syntax name=<em>id</em>&gt;</code>
  <dd> The actor's syntax string.  <code>&lt;add-markup&gt;</code> can be
       used to put it into a suitable form for display.
  <dt> <code>&lt;actor-doc attr=<em>id</em> name=<em>id</em>&gt;</code>
  <dd> Can be used to access any documentation associated with the actor.
</dl>

In addition, all predefined actors have an associated Java handler class in
<code>crc.interform.handle</code>, and the documentation strings are part of
the handler's <code>javadoc</code> documentation.<p>

<hr>
<h2><a name="tagsets">Tagsets</a></h2>

The following tagsets are currently predefined:
<ol>
  <li> HTML<br>
       The syntax of standard HTML 3.2
  <li> <a href="Tagset/tagset.html">tagset</a><br>
       This defines the syntax of tagset definition files.  Read it first,
       since it explains the syntactic constructs used in the other tagset
       definition files.
  <li> <a href="Tagset/basic.html">basic</a><br>
       The definitions of the ``primitive'' tags -- the ones that <em>all</em>
       tagsets use, and that are implemented using Java ``handlers'' rather
       than being defined in terms of other tags.
  <li> <a href="Tagset/xxml.html">xxml</a><br>
       The tagset intended for stand-alone XML processing.  It adds a
       comparatively small number of tags to
       <a href="Tagset/basic.html">basic</a> that are defined in terms of
       other tags. 
  <li> <a href="Tagset/xhtml.html">xhtml</a><br>
       The tagset used in the PIA for HTML processing, containing all the tags
       defined in both <a href="Tagset/xxml.html">standalone</a> and
       HTML. 
  <li> <a href="Tagset/pia-xhtml.html">pia-xhtml</a><br>
       The tagset used in the PIA for HTML processing, containing all the tags
       defined <a href="Tagset/xhtml.html">xhtml</a> along with some tags used
       for formatting InterForm pages.
  <li> <a href="Tagset/Standard-tagset.html">Standard</a> <b>(obsolete)</b><br>
       The ``legacy'' (old) tagset used for expanding agent InterForms in the
       PIA.  
</ol>

These documents are derived automatically from the tagsets themselves, so
although the documentation of each actor may be slightly sketchy in places, it
is at least complete and up-to-date.  Several other, special-purpose tagsets
are also defined; a complete set of documentation can be found in the <a
href="Tagset">Tagset/</a> subdirectory.  <p>

Note that any agent can have a private tagset.  Its name is
<code><em>type</em>-xhtml</code>, where <code><em>type</em></code> is the
agent's ``type''.  For most agents this is the same as the agent's name; DOFS
and Spy are examples of type names. <p>


Also, the following active documents are available if you are viewing this
manual through a PIA:

<dl>
  <dt> <a href="/Agency/entities.if">/Agency/entities</a>
  <dd> <em>Complete</em> listing of defined entities
  <dt> <a href="/Agency/actors.if">/Agency/actors</a> <b>(obsolete)</b>
  <dd> <em>Complete</em> listing of defined (legacy) actors.
  <dt> <a href="/InterForm/tag_man.if">/InterForm/tag_man.if</a>
       <b>(obsolete)</b>
  <dd> the manual for the Standard Tagset (somewhat incomplete).
  <dt> <a href="/InterForm/demo.if">/InterForm/demo.if</a>
       <b>(obsolete)</b>
  <dd> A set of corresponding code examples.
</dl>


<hr>
<h2><a name="invoke">Program Invocation</a></h2>

The Document Processor is invoked either stand-alone as a CGI or filter
(formatter), or as part of the PIA.  The command for invoking the Document
Processor as a filter is: 

<pre>
  process <em>[option]...</em> <em>input_filename</em>
</pre>

The command-line options are:

<dl compact>
  <dt> <code>-e</code>
  <dd> Do not define standard entities.
  <dt> <code>-h</code>
  <dd> print a help string.
  <dt> <code>-o <em>filename</em></code>
  <dd> specify output file
  <dt> <code>-p</code>
  <dd> Build a parse tree (which is output as a serialized Java object)
  <dt> <code>-t <em>tagset-name</em></code>
  <dd> specify tagset (default <code>xhtml</code>).
  <dt> <code>-s</code>
  <dd> silent.  Non-fatal error messages suppressed.
  <dt> <code>-q</code>
  <dd> quiet.  Warnings and informational messages are suppressed.
  <dt> <code>-v</code>
  <dd> verbose.  Additional informational messages are output.
  <dt> <code>-d</code>
  <dd> debugging.  Information is output which may be of use for debugging the
       interpretor. 
</dl>

The CGI version of the InterForm interpretor is:

<pre>
  interform.cgi
</pre>

and information is passed to it according to the <a
href="http://hoohoo.ncsa.uiuc.edu/cgi/">Common Gateway Interface</a>
specification.  The <code>.cgi</code> extension allows some servers (when
suitable configured) to recognize it as a CGI script even if placed in a
user's document directory.<p>


<hr>
<b>Copyright &copy; 1997 Ricoh Silicon Valley</b><br>
<b>$Id$</b><br>
<address><a href="http://www.crc.ricoh.com/people/steve/steve.html"
         >Stephen R. Savitzky</a> &lt;<a href="mailto:steve@crc.ricoh.com"
         >steve@crc.ricoh.com</a>&gt;</address>
</body></html>
