<!doctype html public "-//IETF//DTD HTML//EN//2.0">
<html><head>
<title>PIA InterForm Manual</title>
<link rev="made" href="mailto:steve@crc.ricoh.com"></link>
</head><body>
<h1>PIA InterForm Manual</h1>

<blockquote><em>
  This document is a user's manual for the Platform for Information
  Appliances' InterForm (Interactive/Interpreted Form) markup language.  It is
  an ordinary HTML document, but if you are viewing it through a PIA you will
  be able to use links to an <em>active</em> document, the <a
  href="/if_demo/home.if">InterForm Demonstration Agent</a>.  Other
  information of interest to Agent authors can be found in the <a
  href="../Author/index.html">Agent Author's Manual</a>.
</em></blockquote>

<h3>Related Documents:</h3>

<ul>
  <li> <a href="../Author/index.html">Agent Author's Manual</a>
  <li> <a href="/if_demo/home.if">InterForm Demonstration Agent</a> (from PIA
       only) 
  <li> <a href="/Agency/entities.if">Entities</a> (from PIA only)
  <li> <a href="/Agency/actors.if">Actors</a> (from PIA only)
</ul>

<h3>Contents:</h3>

<ul>
  <li> <a href="#intro">Introduction</a>
  <li> <a href="#interp">The InterForm Interpretor</a>
  <li> <a href="#std_tags">The Standard Tagset</a>
  <li> <a href="#other_tags">Other Tagsets</a>
  <li> <a href="#invoke">Invocation</a>
</ul>

<hr>
<h2><a name="intro">Introduction:  What is an InterForm?</a></h2>

An InterForm is a HTML document that contains some tags that a PIA can
``interpret.''  You can think of an InterForm as an HTML form that doesn't
need a corresponding CGI script to handle it.  You can also think of it as
an ``active'' document that is run through a special-purpose formatter.<p>

Because the extra tags follow strict SGML syntax conventions, InterForms can
be edited with any text editor, or any HTML editor that lets you use new or
non-standard tags, or any SGML editor (at least when we create an extended
DTD).<p> 

We hope that authors will find InterForms to be as easy to use as
word-processor macros or text-formatting style sheets.  Programmers will find
that, in spite of their unfamiliar syntax, InterForms have all the power of
any modern object-based language.<p>

<h3>InterForm Data Structures</h3>

The key idea behind InterForms is <em>computing with documents</em>, so data
in the InterForm system is simply a piece of a document.  Markup is explicitly
included in this, and HTML ``data structures'' are used as much as
possible.<p>

In particular, HTML lists (&lt;ul&gt; and &lt;ol&gt;) are used as lists or
arrays.  Definition Lists (&lt;dl&gt;) are used as ``associative arrays,''
in which you can look up a ``term'' (&lt;dt&gt;) and get the corresponding
data (&lt;dd&gt;).  Similarly, tables (&lt;table&gt;) can be used like
database tables.   This makes it easy to take parts of documents and use them
as data, something most existing systems are not very good at.<p>

In general, all data in an InterForm is in the form of SGML
``<dfn>elements</dfn>.''  An element is either a string of characters, or
a compound object consisting of a <em>start tag</em> and <em>end tag</em>
enclosing some <em>content</em> elements between them.  The element may also
have some named <dfn>attributes</dfn>; attributes and their associated values
appear in the element's start tag.<p>

Strings of ordinary characters are called <dfn>text</dfn>; tags and entities
are called <dfn>markup</dfn>.  Some operations let you operate only on text or
markup.  Markup can be added (for example, by converting a sequence of words
into a list), or removed.<p>


<h3>Entities</h3>

Entities (those things like <code>&amp;copy;</code> that a browser displays as
special characters) are used as variables or macros--they can be defined (and
redefined) and later ``expanded'' (replaced by their definition).  As you
might expect, a definition list can be used for this.  Entities can also be
used as ``iteration variables''--you can repeat a piece of text for every item
in a list, with the <code>&amp;li;</code> entity replaced by each list item in
turn.<p>

<h3>Actors</h3>

Finally, new, <em>active</em> ``elements'' can be defined, complete with their
own start tag, end tag, attributes, and content.  Whenever such an element
appears in a document, a corresponding piece of InterForm data called an
``<dfn>actor</dfn>'' is expanded, with entities bound to the element's
attributes and content.<p>

It is also possible to define ``<dfn>passive</dfn>'' actors, which match
particular ``features'' in a document, usually special attributes or
particular attribute values.<p>

A collection of predefined actors designed to work together should really be
called a ``cast,'' but in fact is called a ``<dfn>tagset</dfn>,'' in part
because it's less likely to be misunderstood--``cast'' has a quite different
meaning in programming languages like C++.  (MetaHTML also uses ``tagset'' in
this sense.)<p>

The PIA defines a <a href="#standard_tagset">standard tagset</a> for use in
InterForms.  Some agents may define special tagsets to be loaded alongside the
standard one.  Completely different tagsets can also be defined for different
kinds of document processing:  parsing HTML, formatting, even translating SGML
documents with other document types <em>into</em> HTML.<p>


<hr>
<h2><a name="interp">The InterForm Interpretor</a></h2>

<h3>Overview</h3>

At this point, astute readers with writing experience will recognize actors
and entities as special kinds of ``macros'' and ``abbreviations,'' and would
suspect that processing an InterForm file involves running it through a kind
of formatting or typesetting engine.  Readers with programming experience
might instead choose to regard them as ``functions'' and ``variables,'' and
expect to find a kind of interpretor.  Both would be perfectly correct.<p>

The InterForm Interpretor (II) operates almost exactly like any other SGML
text-processing application.  It takes in a stream of characters from a file,
an HTTP server, or an input device and turns it into a stream of
``<dfn>tokens</dfn>.''  Each token is either ``<dfn>text</dfn>'' (a string of
ordinary characters), an entity name, or a piece of ``<dfn>markup</dfn>'' -- a
start tag, end tag, or SGML declaration.<p>

Next, any end tags are paired with their corresponding start tag.
Any end tags that may have been omitted (hardly anyone codes ``&lt;/li&gt;,''
the end tag for a list item, for example) are generated automatically. <p>

Also, any entities in the input stream are expanded, which means that input
starts coming from the entity instead of from the original input stream.
(Entities that are not defined, i.e. that have no meaning known to the system,
are simply passed through unchanged.)<p>

Finally the resulting tokens are turned back into characters and sent to an
output stream, usually a user's Web browser.<p>

<em>Actually, things are a little more complicated than that.  But only a
little.</em> <p>

The complication comes in because of actors.  At any point in the process some
actor might ``recognize its cue'' and start expanding.  Unlike entities, which
are simply replaced by a corresponding chunk of text, actors can
<em>process</em> text.  They can, for example, <p>

<ul>
  <li> tell the interpretor to divert incoming tokens to someplace where the
       actor can look at them later
  <li> tell the interpretor to stop expanding entities and recognizing actors
  <li> define new entities, or redefine existing ones
  <li> perform some operations on the current ``element''
  <li> tell the interpretor to replace the current element, its contents,
       or any of its attributes, with new data.
</ul>

<h3>Terminology</h3>

Diverting incoming tokens is called ``<dfn>parsing</dfn>;''  the result
is that the interpretor constructs a compound object consisting of the start
tag and its content--in other words the entire element.<p>

Replacing an element, attribute, or entity with new data is called
``<dfn>expanding</dfn>'' it, because it often (not always) gets bigger as a
result.<p>

Allowing an actor to perform processing on an element is called
``<dfn>applying</dfn>'' the actor to the element.<p>

Associating an entity or attribute name with a value is called
``<dfn>binding</dfn>'' the name to the value.  A value may be anything from a
single character to an entire document with markup.<p>

Processing a stream of incoming tokens (parsing, expanding, and applying
actors) is called ``<dfn>evaluating</dfn>'' it.<p>


<hr>
<h2>The InterForm Language</h2>

<h3>Syntax</h3>

The syntax of the InterForm language is basically that of HTML; more
specifically it is derived from the SGML reference syntax, which it follows
<em>exactly</em>.  Any InterForm can be parsed using an SGML parser (with an
appropriate Document Type Definition).  Most HTML editors can handle
InterForms; all that is needed is the ability to enter non-standard entities
and element tags.  HTML editors can do this because companies like Netscape
and Microsoft keep adding tags faster than the editor vendors can keep up.  An
SGML validator, with an appropriate DTD (document type definition) can be used
to validate the syntactic structure of an InterForm.<p>

<h3>Names</h3>

There are two, slightly different kinds of names (identifiers) in the
InterForm system.  Element tags and attributes start with a letter and contain
any sequence of letters, digits, ``<code>.</code>'' (period) and
``<code>-</code>'' (hyphen) characters.  Case is ignored.  Entities come from
the same character set, but case is significant (the original reason being to
make it easy to represent upper- and lower-case letters in foreign
alphabets).<p>

The practical effect of the case-sensitivity rules is that you can use case to
distinguish entities, where it matters.  On the other hand, you can use case
to improve the readability of different kinds of tags and attributes, for
example special InterForm tags and HTML tags, because it doesn't matter to the
system which ones you use.<p>

URL's and filenames have their own sets of rules, of course, and filenames
differ from one operating system to another.  Other names may refer to
environment variables and software objects in the PIA (agents, for example);
these names are usually case sensitive. <p>

By convention, actors that do not correspond directly to tags (for example,
the one that matches the ``<code>foreach</code>'' attribute) should have names
starting with ``<code>-</code>''; they usually end with it as well.  Within
actor names, ``<code>-</code>'' is used to separate words.  Often the first
word names the PIA data structure acted upon, as in
``<code>agent-running</code>'', which tests whether an agent with a given name
is running.<p>

Many actors accept a large variety of special attributes that modify their
behavior; for example ``<code>&lt;get entity&gt;</code>'' and ``<code>&lt;get
actor&gt;</code>''.  Many specialized versions exist with names like
``<code>get.entity</code>''--the tag and attribute separated by a
``<code>.</code>'' (usually read as ``dot'' or ``point'' in this context).  It
is somewhat more efficient to use these specialized actors, since less work
has to be done by the interpretor in figuring out which action to take.<p>


<h3>Entities</h3>

<dl>
  <dt> entity ::= '&amp;' path ';'?
  <dd> 
  <dt> path ::= identifier ['.' path]?
  <dd> 
  <dt> identifier := [letter | digit | '-']+
  <dd> 
</dl>

An entity reference consists of the character ``<code>&amp;</code>''
(ampersand) followed by a name, followed by the character ``<code>;</code>''
(semicolon).  The semicolon can be omitted if the name of the entity is
followed by a character that is not permitted in a name, but it is good
practice to include it anyway.  Case is <em>significant</em> in entity names.
<p>

An entity name may consist of several sub-names separated by
``<code>.</code>'' (period).  These sub-names form a path (similar to a file
path) through a sequence of ``namespaces'' (which may be Agents, &lt;table&gt;
or &lt;dl&gt; elements, forms, and so on).  If no namespace is given, the
interpretor will search through any locally-defined entities (for example, the
list element entity defined by the &lt;repeat&gt; tag) and the top-level
(global) entity table associated with the InterForm being interpreted.  This
is pre-loaded with a number of useful entities:<p>

===<p>

A complete list can be obtained from the PIA via the <a
href="/Agency/entities.if">/Agency/entities.if</a> InterForm.<p>


The following namespaces are defined:

<dl>
  <dt> <code>AGENT</code>
  <dd> The ``options'' of the PIA agent that owns the InterForm being expanded.
  <dt> <code>TRANS</code>
  <dd> The headers and features of the current transaction.  Defining a new
       entity in this namespace will assert a feature if the feature's name is
       lowercase, and a header if the name is capitalized.
  <dt> <code>LOCAL</code>
  <dd> The local namespace associated with the innermost element that contains
       the entity being expanded.  A new namespace is created if necessary.
  <dt> <code>GLOBAL</code>
  <dd> The namespace associated with the document.  Note that this namespace
       is actually a feature of the document's transaction, and so can be used
       for communication between agents. 
  <dt> <code>FORM</code>
  <dd> The query string or form content associated with a GET or POST query.
</dl>

If a path ends with a namespace, it is returned as a description list or query
string, depending on the context.

<h3>Elements</h3>

The syntax of an Element is:

<dl>
  <dt> element ::= start-tag [content end-tag]
  <dd> (An element that consists only of a start tag is called <em>empty</em>;
       empty elements are distinguished by their tags.
  <dt> start-tag ::= '<' tag [attribute]* '>'
  <dd> 
  <dt> end-tag ::= '</' tag '>' 
  <dd> 
  <dt> content ::= [text | element]*
  <dd> 
  <dt> tag ::= identifier
  <dd> 
  <dt> attribute ::= identifier ['=' value]
  <dd> (No spaces are permitted on either side of the '='.)
  <dt> value ::= identifier | nonblank* | quoted-string
  <dd> 
  <dt> quoted-string ::= quote non-quote* quote
  <dd> 
  <dt> quote := '"' | "'"
  <dd> 
  <dt> identifier ::= [ letter | digit | '-' | '.' ]+
  <dd> 
  <dt> nonblank ::= <em>any character except</em> '"' | "'" | '<' | '>' |
       whitespace 
  <dd> 
  <dt> whitespace ::= <em>any character with code &lt;= ' '.</em>
  <dd> 
</dl>

HTML tags do not contain '-' or '.' characters.  Normally in the InterForm
language '.' is used as a path separator, as in entities, whereas '-' is used
to separate words in a single identifier.  Unlike entities, however, the
namespace for actors is flat, so that this usage is purely a naming
convention. <p>

<blockquote><em>
  Eventually we will want to go to entity-style hierarchical lookup on actor
  tags, possibly with a '<code>-</code>' prefix or some such.  This will
  permit &lt;dl&gt; lists to function as objects.  There may be alternative
  ways of doing this; suggestions would be appreciated.
</em></blockquote>

The order of attributes in a start tag is retained, but is not significant for
any of the predefined actors (or for any of the standard HTML tags, for that
matter).<p>


<h3>Lists</h3>

Several actors (for example, &lt;repeat&gt;) operate on lists: sequences of
``items'' usually represented by the &lt;li&gt; element.  Lists function very
much like <em>arrays</em> in conventional programming languages, or
<em>sets</em> in database languages.<p>

The following elements are treated as simple lists:
<blockquote>
  &lt;ul&gt;, &lt;ol&gt;, &lt;table&gt;, &lt;tr&gt;
</blockquote>

Note that a &lt;table&gt; is therefore a list of lists.  In addition, a
description list (&lt;dl&gt;) can be treated as a list of two-element
(&lt;dt&gt;, &lt;dd&gt;) lists, or as a simple, flat list of alternating names
and values.<p>

A text string, especially an attribute, is turned into a list by splitting it
on whitespace; the &lt;split&gt; actor can be used to split on any text
pattern.<p> 

<em>Any</em> sequence of tokens can be treated as a list, by splitting
it either on whitespace, or on token boundaries.<p>


<h3>Associations</h3>

The following elements can be treated as <em>key</em>=<em>value</em>
associations:

<blockquote>
  &lt;dt&gt;, &lt;table&gt;
</blockquote>

The key in a table is normally just the first item in the row, but rows with a
blank first element (normally a &lt;th&gt;) are appended to the previous
row.  Tables with labeled columns (usually indicated by an initial row of
&lt;th&gt; elements) can be turned into <em>lists</em> of associations.<p>

In addition, any string in the proper form can be used; pairs can be separated
by whitespace or ``<code>&amp;</code>'' characters (as in query strings);
names and values are normally separated by an ``<code>=</code>'' character.<p>

Ordinary lists can be turned into associations by the &lt;associate&gt;
actor, which associates items in pairs.<p>

Any <em>element</em> can be turned into an association (of attributes and
values), optionally with its tag and content associated with special keys,
normally ``<code>-tag-</code>'' and ``<code>-content-</code>'', that cannot be
mistaken for attributes. This is also done using the the &lt;associate&gt;
actor.<p>

Sets of associations are found in conventional programming languages as hash
tables (AWK and Perl), association-lists (LISP), and tuples (relational
database languages).<p>


<h3>Tagsets</h3>

A named collection of actors is called a <dfn>tagset</dfn> (it could have been
called a ``cast,'' since it's a set of actors that work together, but ``cast''
means something quite different in the programming language community).<p>

<h3>Actor Documentation</h3>

Every actor has some associated on-line documentation strings which can be
specified as attributes when the actor is defined (and eventually using
elements inside the actor's body).  These are:

<dl>
  <dt> <code>syntax</code>
  <dd> A regular-expression syntax description for the actor.
  <dt> <code>dscr</code>
  <dd> A narrative description of the actor's semantics.  Uppercase words in
       this description correspond to attributes of the element that invokes
       the actor.
  <dt> <code>note</code>
  <dd> Any additional information, in text form.
  <dt> <code>doc</code>
  <dd> Full documentation, usually in HTML form.
</dl>

The following actors are used to access an actor's documentation:

<dl>
  <dt> <code>&lt;actor-attrs name=<em>id</em>&gt;</code>
  <dd> The attributes of the actor, <em>except for the documentation
       attributes</em>, as specified in the <code>&lt;actor&gt;</code> element
       that defined the actor. 
  <dt> <code>&lt;actor-dscr name=<em>id</em>&gt;</code>
  <dd> The actor's description string.  <code>&lt;add-markup&gt;</code> can be
       used to convert capitalized names to boldface, and so on.
  <dt> <code>&lt;actor-syntax name=<em>id</em>&gt;</code>
  <dd> The actor's syntax string.  <code>&lt;add-markup&gt;</code> can be
       used to put it into a suitable form for display.
  <dt> <code>&lt;actor-doc attr=<em>id</em> name=<em>id</em>&gt;</code>
  <dd> Can be used to access any documentation associated with the actor.
</dl>

In addition, all predefined actors have an associated Java handler class in
<code>crc.interform.handle</code>, and the documentation strings are part of
the handler's <code>javadoc</code> documentation.<p>

<hr>
<h2>The <a name="std_tags">Standard Tagset</a></h2>

<dl>
  <dt> <b>Note:</b>
  <dd> <em>Complete</em> listings of defined <a
       href="/Agency/actors.if" >actors</a> and <a href="/Agency/entities.if"
       >entities</a> can be obtained from your PIA.  The <a
       href="/if_demo">InterForm Demo</a> agent has more information,
       including sample code for each actor.
  <dt> <b>Note:</b>
  <dd> This section is derived <em>automatically</em> from the active
       document, <a href="/if_demo/tag_man.if">/if_demo/tag_man.if</a>.
</dl>

<hr>
<h2><a name="other_tags">Other Tagsets</a></h2>

<h3>Safe</h3>

The <b>Safe</b> tagset consists of the subset of the <b>Standard</b> tagset
that affects only the file being processed.  It is, consequently, safe to use
the <b>Safe</b> tagset on InterForm files owned by some other user, received
in e-mail, or retrieved from elsewhere in the Web.  The DOFS agent uses the
<b>Safe</b> tagset to process <code>index.if</code> files.<p>

<h3>Secure</h3>

The <b>Secure</b> tagset consists of the subset of the <b>Standard</b> tagset
that cannot convey information outside the PIA's host computer; it does not
contain any tags that invoke commands or make HTTP requests.<p>

<h3>StandAlone</h3>

The <b>StandAlone</b> tagset consists of the subset of the <b>Standard</b>
tagset that does not require a PIA.  It is used when the InterForm Interpretor
is operating as a filter or CGI rather than as a part of the PIA.<p>

<h3>Basic</h3>

The <b>Basic</b> tagset consists of the subset of the <b>Standard</b> tagset
that operates entirely within the InterForm file; it is roughly speaking the
intersection of <b>Safe</b> and <b>Secure</b>.<p>


<h3>HTML</h3>

The <b>HTML</b> tagset consists of exactly those tags and entities required
to parse HTML.  No processing is done.  This tagset is usually augmented with
tags that perform specific processing tasks such as extracting links,
submitting or updating forms, or formatting.  Specifically,

<h4>Extraction</h4>

These tagsets are used for extracting specific types of data from a file.
They are usually used with the &lt;file parse tagset=<em>whatever</em>&gt;
actor.

<dl>
  <dt> <b>Extract-HREF</b>
  <dd> extract all <code>href=</code> attributes, returning a list of
       URL's pointing at pages linked to. 
  <dt> <b>Extract-SRC</b>
  <dd> extract all <code>src=</code> attributes, returning a list of
       URL's pointing at images.
  <dt> <b>Extract-Text</b>
  <dd> extract all the text (content), returning a single string.
  <dt> <b>Extract-Links</b>
  <dd> Returns a list of URL/text pairs.
</dl>

<hr>
<h2><a name="invoke">Invocation</a></h2>

The InterForm Interpretor is invoked either stand-alone as a CGI or filter
(formatter), or as part of the PIA.

<hr>
<b>$Id$</b><br>
<!-- hhmts start -->
Last modified: Wed Jul 23 14:28:09 1997
<!-- hhmts end -->
<p>
<address><a href="http://www.crc.ricoh.com/people/steve/steve.html"
         >Stephen R. Savitzky</a> &lt;<a href="mailto:steve@crc.ricoh.com"
         >steve@crc.ricoh.com</a>&gt;</address>
</body></html>
