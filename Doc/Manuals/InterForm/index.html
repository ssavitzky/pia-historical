<!doctype html public "-//IETF//DTD HTML//EN//2.0">
<html><head>
<title>PIA InterForm Manual</title>
<link rev="made" href="mailto:steve@crc.ricoh.com"></link>
</head><body>
<h1>PIA InterForm Manual</h1>

<blockquote><em>
  This document is a user's manual for the Personal Information Agency's
  InterForm (Interactive/Interpreted Form) markup language.  It is an ordinary
  HTML document, but if you are viewing it through a PIA you will be able to
  use links to an <em>active</em> document, the <a
  href="/if_demo/home.if">InterForm Demonstration Agent</a>.  Other
  information of interest to Agent authors can be found in the <a
  href="../Author/index.html">Agent Author's Manual</a>.
</em></blockquote>

<h3>Related Documents:</h3>

<ul>
  <li> <a href="../Author/index.html">Agent Author's Manual</a>
  <li> <a href="/if_demo/home.if">InterForm Demonstration Agent</a> (from PIA
       only) 
  <li> <a href="/agency/entities.if">Entities</a> (from PIA only)
  <li> <a href="/agency/actors.if">Actors</a> (from PIA only)
</ul>

<h3>Contents:</h3>

<ul>
  <li> <a href="#intro">Introduction</a>
</ul>

<hr>
<h2><a name="intro">Introduction:  What's an InterForm?</a></h2>

An InterForm is a HTML document that contains some tags that a PIA can
``interpret.''  You can think of an InterForm as an HTML form that doesn't
need a corresponding CGI script to handle it.  You can also think of it as
an ``active'' document that is run through a special-purpose formatter.<p>

Because the extra tags follow strict SGML syntax conventions, InterForms can
be edited with any text editor, or any HTML editor that lets you use new or
non-standard tags, or any SGML editor (at least when we create an extended
DTD).<p> 

We hope that authors will find InterForms to be as easy to use as
word-processor macros or text-formatting style sheets.  Programmers will find
that, in spite of their unfamiliar syntax, InterForms have all the power of
any modern object-based language.<p>

<h3>InterForm Data Structures</h3>

The key idea behind InterForms is <em>computing with documents</em>, so data
in the InterForm system is simply a piece of a document.  Markup is explicitly
included in this, and HTML ``data structures'' are used as much as
possible.<p>

In particular, HTML lists (&lt;ul&gt; and &lt;ol&gt;) are used as lists or
arrays.  Definition Lists (&lt;dl&gt;) are used as ``associative arrays,''
in which you can look up a ``term'' (&lt;dt&gt;) and get the corresponding
data (&lt;dd&gt;).  Similarly, tables (&lt;table&gt;) can be used like
database tables.   This makes it easy to take parts of documents and use them
as data, something most existing systems are not very good at.<p>

In general, all data in an InterForm is in the form of SGML
``<dfn>elements</dfn>.''  An element is either a string of characters, or
a compound object consisting of a <em>start tag</em> and <em>end tag</em>
enclosing some <em>content</em> elements between them.  The element may also
have some named <dfn>attributes</dfn>; attributes and their associated values
appear in the element's start tag.<p>

Strings of ordinary characters are called <dfn>text</dfn>; tags and entities
are called <dfn>markup</dfn>.  Some operations let you operate only on text or
markup.  Markup can be added (for example, by converting a sequence of words
into a list), or removed.<p>


<h3>Entities</h3>

Entities (those things like <code>&amp;copy;</code> that a browser displays as
special characters) are used as variables or macros--they can be defined (and
redefined) and later ``expanded'' (replaced by their definition).  As you
might expect, a definition list can be used for this.  Entities can also be
used as ``iteration variables''--you can repeat a piece of text for every item
in a list, with the <code>&amp;li;</code> entity replaced by each list item in
turn.<p>

<h3>Actors</h3>

Finally, new, <em>active</em> ``elements'' can be defined, complete with their
own start tag, end tag, attributes, and content.  Whenever such an element
appears in a document, a corresponding piece of InterForm data called an
``<dfn>actor</dfn>'' is expanded, with entities bound to the element's
attributes and content.<p>

It is also possible to define ``<dfn>passive</dfn>'' actors, which match
particular ``features'' in a document, usually special attributes or
particular attribute values.<p>

A collection of predefined actors designed to work together should really be
called a ``cast,'' but in fact is called a ``<dfn>tagset</dfn>,'' in part
because it's less likely to be misunderstood--``cast'' has a quite different
meaning in programming languages like C++.  (MetaHTML also uses ``tagset'' in
this sense.)<p>

The PIA defines a <a href="#standard_tagset">standard tagset</a> for use in
InterForms.  Some agents may define special tagsets to be loaded alongside the
standard one.  Completely different tagsets can also be defined for different
kinds of document processing:  parsing HTML, formatting, even translating SGML
documents with other document types <em>into</em> HTML.<p>


<hr>
<h2>The InterForm Interpretor</h2>

<h3>Overview</h3>

At this point, astute readers with writing experience will recognize actors
and entities as special kinds of ``macros'' and ``abbreviations,'' and would
suspect that processing an InterForm file involves running it through a kind
of formatting or typesetting engine.  Readers with programming experience
might instead choose to regard them as ``functions'' and ``variables,'' and
expect to find a kind of interpretor.  Both would be perfectly correct.<p>

The InterForm Interpretor (II) operates almost exactly like any other SGML
text-processing application.  It takes in a stream of characters from a file,
an HTTP server, or an input device and turns it into a stream of
``<dfn>tokens</dfn>.''  Each token is either ``<dfn>text</dfn>'' (a string of
ordinary characters), an entity name, or a piece of ``<dfn>markup</dfn>'' -- a
start tag, end tag, or SGML declaration.<p>

Next, any end tags are paired with their corresponding start tag.
Any end tags that may have been omitted (hardly anyone codes ``&lt;/li&gt;,''
the end tag for a list item, for example) are generated automatically. <p>

Also, any entities in the input stream are expanded, which means that input
starts coming from the entity instead of from the original input stream.
(Entities that are not defined, i.e. that have no meaning known to the system,
are simply passed through unchanged.)<p>

Finally the resulting tokens are turned back into characters and sent to an
output stream, usually a user's Web browser.<p>

<em>Actually, things are a little more complicated than that.  But only a
little.</em> <p>

The complication comes in because of actors.  At any point in the process some
actor might ``recognize its cue'' and start expanding.  Unlike entities, which
are simply replaced by a corresponding chunk of text, actors can
<em>process</em> text.  They can, for example, <p>

<ul>
  <li> tell the interpretor to divert incoming tokens to someplace where the
       actor can look at them later
  <li> tell the interpretor to stop expanding entities and recognizing actors
  <li> define new entities, or redefine existing ones
  <li> perform some operations on the current ``element''
  <li> tell the interpretor to replace the current element, its contents,
       or any of its attributes, with new data.
</ul>

<h3>Terminology</h3>

Diverting incoming tokens is called ``<dfn>parsing</dfn>;''  the result
is that the interpretor constructs a compound object consisting of the start
tag and its content--in other words the entire element.<p>

Replacing an element, attribute, or entity with new data is called
``<dfn>expanding</dfn>'' it, because it often (not always) gets bigger as a
result.<p>

Allowing an actor to perform processing on an element is called
``<dfn>applying</dfn>'' the actor to the element.<p>

Associating an entity or attribute name with a value is called
``<dfn>binding</dfn>'' the name to the value.  A value may be anything from a
single character to an entire document with markup.<p>

Processing a stream of incoming tokens (parsing, expanding, and applying
actors) is called ``<dfn>evaluating</dfn>'' it.<p>


<hr>
<h2>The InterForm Language</h2>

<h3>Syntax</h3>

The syntax of the InterForm language is basically that of HTML; more
specifically it is derived from the SGML reference syntax, which it follows
<em>exactly</em>.  Any InterForm can be parsed using an SGML parser (with an
appropriate Document Type Definition).  Most HTML editors can handle
InterForms; all that is needed is the ability to enter non-standard entities
and element tags.  HTML editors can do this because companies like Netscape
and Microsoft keep adding tags faster than the editor vendors can keep up.  An
SGML validator, with an appropriate DTD (document type definition) can be used
to validate the syntactic structure of an InterForm.<p>

<h3>Names</h3>

There are two, slightly different kinds of names (identifiers) in the
InterForm system.  Element tags and attributes start with a letter and contain
any sequence of letters, digits, ``<code>.</code>'' (period) and
``<code>-</code>'' (hyphen) characters.  Case is ignored.  Entities come from
the same character set, but case is significant (the original reason being to
make it easy to represent upper- and lower-case letters in foreign
alphabets).<p>

The practical effect of the case-sensitivity rules is that you can use case to
distinguish entities, where it matters.  On the other hand, you can use case
to distinguish different kinds of tags and attributes, for example special
InterForm tags and HTML tags, because it doesn't matter to the system which
ones you use.<p>

URL's and filenames have their own sets of rules, of course, and filenames
differ from one operating system to another.  Other names may refer to
environment variables and software objects in the PIA (agents, for example);
these names are usually case sensitive. <p>

By convention, actors that do not correspond directly to tags (for example,
the one that matches the ``<code>foreach</code>'' attribute) should have names
starting with ``<code>-</code>''; they usually end with it as well.  Within
actor names, ``<code>-</code>'' is used to separate words.  Often the first
word names the PIA data structure acted upon, as in
``<code>agent-running</code>'', which tests whether an agent with a given name
is running.<p>

Many actors accept a large variety of special attributes that modify their
behavior; for example ``<code>&lt;get entity&gt;</code>'' and ``<code>&lt;get
actor&gt;</code>''.  Many specialized versions exist with names like
``<code>get.entity</code>''--the tag and attribute separated by a
``<code>.</code>'' (usually read as ``dot'' or ``point'' in this context).  It
is somewhat more efficient to use these specialized actors, since less work
has to be done by the interpretor in figuring out which action to take.<p>


<h3>Entities</h3>

===<p>


<h3>Elements</h3>

===<p>


<h3>Lists</h3>

Several actors (for example, &lt;repeat&gt;) operate on lists: sequences of
``items'' usually represented by the &lt;li&gt; element.  Lists function very
much like <em>arrays</em> in conventional programming languages, or
<em>sets</em> in database languages.<p>

The following elements are treated as simple lists:
<blockquote>
  &lt;ul&gt;, &lt;ol&gt;, &lt;table&gt;, &lt;tr&gt;
</blockquote>

Note that a &lt;table&gt; is therefore a list of lists.  In addition, a
description list (&lt;dl&gt;) can be treated as a list of two-element
(&lt;dt&gt;, &lt;dd&gt;) lists, or as a simple, flat list of alternating names
and values.<p>

A text string, especially an attribute, is turned into a list by splitting it
on whitespace; the &lt;split&gt; actor can be used to split on any text
pattern.<p> 

<em>Any</em> sequence of tokens can be treated as a list, by splitting
it either on whitespace, or on token boundaries.<p>


<h3>Associations</h3>

The following elements can be treated as <em>key</em>=<em>value</em>
associations:

<blockquote>
  &lt;dt&gt;, &lt;table&gt;
</blockquote>

The key in a table is normally just the first item in the row, but rows with a
blank first element (normally a &lt;th&gt;) are appended to the previous
row.  Tables with labeled columns (usually indicated by an initial row of
&lt;th&gt; elements) can be turned into <em>lists</em> of associations.<p>

In addition, any string in the proper form can be used; pairs can be separated
by whitespace or ``<code>&amp;</code>'' characters (as in query strings);
names and values are normally separated by an ``<code>=</code>'' character.<p>

Ordinary lists can be turned into associations by the &lt;associate&gt;
actor, which associates them in pairs.<p>

Any <em>element</em> can be turned into an association (of attributes and
values), optionally with its tag and content associated with special keys,
normally ``<code>-tag-</code>'' and ``<code>-content-</code>'', that cannot be
mistaken for attributes. This is also done using the the &lt;associate&gt;
actor.<p>

Sets of associations are found in conventional programming languages as hash
tables (AWK and Perl), association-lists (LISP), and tuples (relational
database languages).<p>


<h3>URL Extensions</h3>


<h3>Tagsets</h3>

A named collection of actors is called a <dfn>tagset</dfn> (it could have been
called a ``cast,'' since it's a set of actors that work together, but ``cast''
means something quite different in the programming language community).<p>


<hr>
<h2>The <a name="std_tags">Standard Tagset</a></h2>

<dl>
  <dt> <b>Note:</b>
  <dd> <em>Complete</em> listings of defined <a
       href="/agency/actors.if" >actors</a> and <a href="/agency/entities.if"
       >entities</a> can be obtained from your PIA.  The <a
       href="/if_demo">InterForm Demo</a> agent has more information,
       including sample code for each actor.
  <dt> <b>Note:</b>
  <dd> This section is derived <em>automatically</em> from the active
       document, <a href="/if_demo/tag_man.if">/if_demo/tag_man.if</a>.
</dl>

<hr>
<h2><a name="other_tags">Other Tagsets</a></h2>

<h3>Safe</h3>

The <b>Safe</b> tagset consists of the subset of the <b>Standard</b> tagset
that affects only the file being processed.  It is, consequently, safe to use
the <b>Safe</b> tagset on InterForm files owned by some other user, received
in e-mail, or retrieved from elsewhere in the Web.  The DOFS agent uses the
<b>Safe</b> tagset to process <code>index.if</code> files.<p>

<h3>HTML</h3>

The <b>HTML</b> tagset consists of exactly those tags and entities required
to parse HTML.  No processing is done.  This tagset is usually augmented with
tags that perform specific processing tasks such as extracting links,
submitting or updating forms, or formatting.  Specifically,

<h4>Extraction</h4>

These tagsets are used for extracting specific types of data from a file.
They are usually used with the &lt;file parse tagset=<em>whatever</em>&gt;
actor.

<dl>
  <dt> <b>Extract-HREF</b>
  <dd> extract all <code>href=</code> attributes, returning a list of
       URL's pointing at pages linked to. 
  <dt> <b>Extract-SRC</b>
  <dd> extract all <code>src=</code> attributes, returning a list of
       URL's pointing at images.
  <dt> <b>Extract-Text</b>
  <dd> extract all the text (content), returning a single string.
  <dt> <b>Extract-Links</b>
  <dd> Returns a list of URL/text pairs.
</dl>

<h4>Updating</h4>

These tagsets are usually used with the &lt;file edit
tagset=<em>whatever</em>&gt; actor to perform specific modifications to
files. 

<dl>
  <dt> <b>Update-Form</b>
  <dd> Updates the &lt;input&gt; tags in a form with values in the
       ``&amp;query;'' entity.  If there are several forms in the document,
       the correct one is selected by matching the names and values of
       &lt;input type=submit&gt; and &lt;input type=hidden&gt; elements.
</dl>

<h4>Other Operations</h4>

<dl>
  <dt> <b>Submit-Forms</b>
  <dd> Submits every form in the file.
</dl>

<hr>
<b>$Id$</b><br>
<!-- hhmts start -->
Last modified: Sat Feb  1 20:34:00 1997
<!-- hhmts end -->
<p>
<address><a href="http://www.crc.ricoh.com/people/steve/steve.html"
         >Stephen R. Savitzky</a> &lt;<a href="mailto:steve@crc.ricoh.com"
         >steve@crc.ricoh.com</a>&gt;</address>
</body></html>
