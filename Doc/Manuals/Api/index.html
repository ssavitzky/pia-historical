<!doctype html system "html.dtd">
<html><head>
<title>PIA Internals Manual</title>
<link rev="made" href="mailto:steve@crc.ricoh.com">
</head><body>
<h1>PIA Internals Manual</h1>

<blockquote>
  This manual describes the internal workings of the PIA, including the
  Application Programming Interface.
</blockquote>

<h3>Contents</h3>
<ul>
  <li> <a href="#implementation">Implementation</a>
  <li> <a href="#resolver">The PIA Resolver</a>
  <li> <a href="#agents">Agents</a>
  <li> <a href="#interforms">The InterForm Interpretor</a>
  <li> <a href="JavaDoc/">Java Documentation</a><br>
       <a href="JavaDoc/packages.html">Packages</a>,
       <a href="JavaDoc/tree.html">Class Hierarchy</a>,
       <a href="JavaDoc/AllNames.html">Index</a>
</ul>

<hr>
<h2><a name="implementation">Implementation</a></h2>

The PIA is implemented in Java.  Complete documentation of the Java 
<a href="JavaDoc/packages.html">packages</a> and 
<a href="JavaDoc/tree.html">classes</a> can be found in the
<a href="JavaDoc/">JavaDoc</a> subdirectory of this Manual.  This
documentation also includes the JavaDoc descriptions of the standard Java
packages used by the PIA.
<p>

There are two classes with useable main programs (several others have main
programs for test purposes):
<ol>
  <li> <a href="JavaDoc/crc.pia.Pia.html">crc.pia.Pia</a><br>
       the main program of the PIA itself.
  <li> <a href="JavaDoc/crc.interform.Filter.html">crc.interform.Filter</a><br>
       a stand-alone implementation of the InterForm interpretor for use as a
       stream filter, document processor, or CGI script.
</ol>

Both are accessible via small wrapper programs in the <code><a
href="../../../bin">pia/bin</a></code> directory:

<ol>
  <li> <a href="../../../bin/pia"><code>bin/pia</code></a> (and
       <code>pia.exe</code> for Windows)
  <li> <a href="../../../bin/filter"><code>bin/filter</code></a> (and
       <code>filter.exe</code> for Windows)
  <li> <a href="../../../bin/interform.cgi"><code>bin/interform.cgi</code></a>
       (and <code>interform.exe</code> for Windows)
</ol>

Note that all are stand-alone applications.  None of these programs can be
used inside a browser as applets; since the PIA is basically a server, an
applet would not be particularly useful.<p>

<h3>Packages</h3>

The PIA is implemented using the following packages:

<dl>
  <dt> <a href="JavaDoc/Package-crc.ds.html">crc.ds</a>
  <dd> generic <em>Data Structures</em>.  Some were originally written with an
       interface that makes it easy to translate similar constructs in PERL.
       In particular, most return <code>null</code> on out-of-range keys or
       indices instead of throwing an exception.
  <dt> <a href="JavaDoc/Package-crc.gnu.regexp.html">crc.gnu.regexp</a>
  <dd> A <em>regular-expression</em> package.  Copyright (C) 1997 Shugo Maeda
       under the GNU General Public License.
  <dt> <a href="JavaDoc/Package-crc.interform.html">crc.interform</a>
  <dd> The <em>InterForm</em> Interpretor.
  <dt> <a href="JavaDoc/Package-crc.interform.handle.html">crc.interform.handle</a>
  <dd> Classes that <em>handle</em> particular InterForm <a
       href="JavaDoc/crc.interform.Actor">Actor</a>s or <a
       href="JavaDoc/crc.interform.Tagset">Tagset</a>s. 
  <dt> <a href="JavaDoc/Package-crc.pia.html">crc.pia</a>
  <dd> The <em>PIA</em> itself, and in general everything that deals with HTTP
       <a href="JavaDoc/crc.pia.Transaction.html">Transaction</a>s.
  <dt> <a href="JavaDoc/Package-crc.pia.agent.html">crc.pia.agent</a>
  <dd> ``Handle'' classes that implement individual <a
       href="JavaDoc/crc.pia.Agent.html">Agent</a>s.
  <dt> <a href="JavaDoc/Package-crc.sgml.html">crc.sgml</a>
  <dd> Classes that implement or operate on <a
       href="JavaDoc/crc.sgml.SGML.html">SGML</a> documents and their
       components.
  <dt> <a href="JavaDoc/Package-crc.tf.html">crc.tf</a>
  <dd> Classes that implement <em>Transaction Features</em> for <a
       href="JavaDoc/crc.pia.Agent.html">Agent</a>s to match.
  <dt> <a href="JavaDoc/Package-crc.util.html">crc.util</a>
  <dd> <em>Utility</em> classes, mainly to implement operations that belong on
       standard Java objects, but have to be implemented statically because
       many standard classes can't be extended.
</dl>

Handler classes in
<a href="JavaDoc/Package-crc.interform.handle.html">crc.interform.handle</a>,
<a href="JavaDoc/Package-crc.pia.agent.html">crc.pia.agent</a>, and
<a href="JavaDoc/Package-crc.tf.html">crc.tf</a> are loaded by name when
needed. <p>


<h3>Note:</h3>

As of the Alpha release this manual is still under construction.  Suggestions
about what else to include would be greatly appreciated.<p>


<hr>
<h2><a name="resolver">The Resolver</a></h2>

The heart of the PIA is a class called the ``<a
href="JavaDoc/crc.pia.Resolver.html">Resolver</a>'' which makes the
association between HTTP ``<a
href="JavaDoc/crc.pia.Transaction.html">Transaction</a>''s and the
<a href="JavaDoc/crc.pia.Agent.html">Agent</a>s that operate on them.
<p>

The <a href="JavaDoc/crc.pia.Resolver.html">Resolver</a> operates in two
phases:

<ol>
  <li> In the first phase, <a href="JavaDoc/crc.pia.Agent.html">Agent</a>s
       are matched with the <a
       href="JavaDoc/crc.pia.Transaction.html">Transaction</a>'s
       <a href="JavaDoc/crc.pia.Feature.html">Feature</a>s according to their
       match <a href="JavaDoc/crc.pia.Criteria.html">Criteria</a>, and are
       allowed to <a href="JavaDoc/crc.pia.Agent.html#actOn">act on</a> the
       matched <a href="JavaDoc/crc.pia.Transaction.html">Transaction</a>.

  <li> In the second, any <a href="JavaDoc/crc.pia.Agent.html">Agent</a>s that
       have been registered (during the first phase) as a ``handler'' are
       invoked to ``<a href="JavaDoc/crc.pia.Transaction.html#satisfy">
       satisfy</a> the <a href="JavaDoc/crc.pia.Transaction.html">
       Transaction</a>, usually by forwarding it to a client or server.
</ol>

Clients and servers are represented in the PIA by proxy objects called
``<a href="JavaDoc/crc.pia.Machine.html">Machine</a>''s which contain the
streams that connect to the client or server, and possibly some associated
information.  A <a href="JavaDoc/crc.pia.Machine.html">Machine</a> is
responsible for the communication protocol required by the client or server to
which it is connected. <p>


<h3>The Resolver Algorithm</h3>

Given a resolver R:

<ol>
  <li> Input:<br>
       Check for incoming messages.  For each message M:
       <ol>
	 <li> Push M onto R's queue Q.
       </ol>
  <li> Next Transaction:<br>
       Shift the next transaction T from Q
  <li> Resolution:<br>
       For each agent A:
       <ol>
	 <li> match A's <code>criteria</code> against T's
	      <code>features</code>. 
	 <li> If A and T match, call A's <code>actOn</code> method with T and
	      R. 
       </ol>
  <li> Satisfaction:<br>
       For each object S on T's <code>satisfiers</code> queue:
       <ol>
	 <li> call S's <code>handle</code> method with T and R.
       </ol>
  <li> Finishing:<br>
       If no S returned <code>true</code>,
       <ol>
	 <li> if T is a request, push an error response onto Q.
	 <li> if T is a response, forward it to its requestor.
       </ol>
  <li> repeat from step 1.
</ol>


<hr>
<h2><a name="agents">Agents</a></h2>

An Agent in the PIA is represented internally by a class that implements the
<a href="JavaDoc/crc.pia.Agent.html">Agent</a> interface.  In practice, all of
them descend from <a
href="JavaDoc/crc.pia.GenericAgent.html">GenericAgent</a>.  Many Agents are,
in fact, implemented directly by <a
href="JavaDoc/crc.pia.GenericAgent.html">GenericAgent</a>, the main exceptions
at the moment being <a href="JavaDoc/crc.pia.Agency.html">Agency</a>, <a
href="JavaDoc/crc.pia.Dofs.html">Dofs</a>, and <a
href="JavaDoc/crc.pia.Logo.html">Logo</a>.  Cache, when we implement it, will
probably also require its own class.<p>

The main reason for implementing an Agent as a separate class so that the Java
code can grab control before dispatching a URL to an InterForm.  Efficiency
(<a href="JavaDoc/crc.pia.Agency.html">Agency</a>) and the ability to handle
non-HTML data (<a href="JavaDoc/crc.pia.Logo.html">Logo</a>) also play a part,
although in fact <a href="JavaDoc/crc.pia.Logo.html">Logo</a> is currently
implemented by dispatching to a <code>PERL</code> program.<p>


<hr>
<h2><a name="interforms">The InterForm Interpretor</a></h2>


<h3>The InterForm Interpretor Algorithm</h3>

Given an interpretor II:

<ol>
  <li> Input:<br>
       Check for an incoming token and push it onto II's input stack S.
  <li> Next Token:<br>
       Pop the next token T from the input stack S.  It may be either a start
       tag, an end tag, or a complete token (a string, an empty tag, or a parse
       tree returned as the result of a computation).
       <ol>
	 <li> If T is a start tag, push it along with the current state onto
	      the parse stack PS and set ``parsing'' in the state.
	 <li> If T is an end tag, pop PS.
       </ol>
  <li> Resolution:<br>
       For each actor A:
       <ol>
	 <li> match A's <code>criteria</code> against T's
	      <code>features</code>. 
	 <li> If A and T match, call A's <code>actOn</code> method with T and
	      II. 
       </ol>
  <li> Satisfaction:<br>
       For each object S on T's <code>satisfiers</code> queue:
       <ol>
	 <li> call S's <code>handle</code> method with T and II.
       </ol>
  <li> Finishing:<br>
       If T is non-null,
       <ol>
	 <li> if II is ``parsing'', push T into the content of the top token
	      in PS. 
	 <li> if II is ``streaming'', push T into the output queue.
       </ol>
  <li> repeat from step 2.
</ol>

It can easily be seen that this is a variation on the Resolver algorithm,
above.  The major difference is the separation between the input and parse
stacks. <p>


<hr>
<b>Copyright &copy; 1997 Ricoh Silicon Valley</b><br>
<b>$Id$</b><br>
</body></html>
