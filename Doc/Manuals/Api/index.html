<!doctype html system "html.dtd">
<html><head>
<title>PIA Internals Manual</title>
<link rev="made" href="mailto:steve@crc.ricoh.com"></link>
</head><body>
<h1>PIA Internals Manual</h1>

<blockquote>
  This manual describes the internal workings of the PIA.
</blockquote>

<h3>Contents</h3>
<ul>
  <li> <a href="#implementation">Implementation</a>
  <li> <a href="#resolver">The PIA Resolver</a>
  <li> <a href="#interpretor">The InterForm Interpretor</a>
  <li> <a href="JavaDoc/">Java Documentation</a><br>
       <a href="JavaDoc/packages.html">Packages</a>,
       <a href="JavaDoc/tree.html">Class Hierarchy</a>,
       <a href="JavaDoc/AllNames.html">Index</a>
</ul>

<hr>
<h2><a name="implementation">Implementation</a></h2>


<hr>
<h2><a name="resolver">The Resolver</a></h2>

<h3>The Resolver Algorithm</h3>

Given a resolver R:

<ol>
  <li> Input:<br>
       Check for incoming messages.  For each message M:
       <ol>
	 <li> Push M onto R's queue Q.
       </ol>
  <li> Next Transaction:<br>
       Shift the next transaction T from Q
  <li> Resolution:<br>
       For each agent A:
       <ol>
	 <li> match A's <code>criteria</code> against T's
	      <code>features</code>. 
	 <li> If A and T match, call A's <code>act_on</code> method with T and
	      R. 
       </ol>
  <li> Satisfaction:<br>
       For each object S on T's <code>satisfiers</code> queue:
       <ol>
	 <li> call S's <code>handle</code> method with T and R.
       </ol>
  <li> Finishing:<br>
       If no S returned <code>true</code>,
       <ol>
	 <li> if T is a request, push an error response onto Q.
	 <li> if T is a response, forward it to its requestor.
       </ol>
  <li> repeat from step 1.
</ol>


<hr>
<h2>The InterForm Interpretor</h2>


<h3>The InterForm Interpretor Algorithm</h3>

Given an interpretor II:

<ol>
  <li> Input:<br>
       Check for an incoming token and push it onto II's input stack S.
  <li> Next Token:<br>
       Pop the next token T from the input stack S.  It may be either a start
       tag, an end tag, or a complete token (a string, an empty tag, or a parse
       tree returned as the result of a computation).
       <ol>
	 <li> If T is a start tag, push it along with the current state onto
	      the parse stack PS and set ``parsing'' in the state.
	 <li> If T is an end tag, pop PS.
       </ol>
  <li> Resolution:<br>
       For each actor A:
       <ol>
	 <li> match A's <code>criteria</code> against T's
	      <code>features</code>. 
	 <li> If A and T match, call A's <code>act_on</code> method with T and
	      II. 
       </ol>
  <li> Satisfaction:<br>
       For each object S on T's <code>satisfiers</code> queue:
       <ol>
	 <li> call S's <code>handle</code> method with T and II.
       </ol>
  <li> Finishing:<br>
       If T is non-null,
       <ol>
	 <li> if II is ``parsing'', push T into the content of the top token
	      in PS. 
	 <li> if II is ``streaming'', push T into the output queue.
       </ol>
  <li> repeat from step 2.
</ol>

It can easily be seen that this is a variation on the Resolver algorithm,
above.  The major difference is the separation between the input and parse
stacks. <p>


<hr>
<b>Copyright &copy; 1997 Ricoh Silicon Valley</b><br>
<b>$Id$</b><br>
</body></html>
