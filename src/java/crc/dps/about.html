<!doctype html public "-//IETF//DTD HTML//EN//2.0">
<html><head>
<title>About the Document Processing System</title>
<link rev="made" href="mailto:steve@rsv.ricoh.com">
</head><body>
<h1>About the Document Processing System</h1>

<blockquote><em>
  This document contains notes about the PIA's Document Processing System
  (DPS), as implemented in the Java module <code>crc.dps</code>.
</em></blockquote>

<h3>See Also:</h3>
<ul>
  <li> <a href="handle/about.html">About Handlers</a> in
       <a href="handle/"><code>handle/</code></a>
</ul>

<h2>Philosophy</h2>

The DPS has several ways of looking at a document:

<ul>
  <li> As a character stream
  <li> As a parse tree
  <li> As a program, which ``expands'' (evaluates) to a document.
</ul>

An InterForm could be viewed as an active document (program) which expands
into a character stream.  The easy way to implement an InterForm under this
view would be to use the <code>toString</code> method on <code>Node</code>.
Active nodes would simply expand appropriately by overriding the
<code>toString</code> method, and everything would be cool.  <p>

There are several problems with this:
<ol>
  <li> In some cases the InterForm is represented as a stream (file), and we
       want to expand it ``on the fly''.
  <li> In other cases, we want the result to be another parse tree. 
  <li> In yet other cases, we want the result to be something else altogether,
       for example nothing (evaluation for side effects), a bitmap (rendering
       on the screen or for print), or a totally transformed document.
  <li> Sometimes we want to do all three:  expand into a stream, modify the
       original InterForm parse tree itself, and store the modified parse tree
       back into the original file.
  <li> What's worse, we want to be able to process the same document in
       different ways (e.g. expanding it or pretty-printing it).
</ol>

As a result, we prefer to view an InterForm as an ActiveDocument composed of
Nodes (some of) which implement the ActiveNode interface.  <em>Active</em>
nodes simply expand into more nodes.  The classes whose names start with
``<code>ParseTree</code>'' in <code>crc.dps.active</code> implement the
<code>ActiveNode</code> interface. <p>

The efficient way to accomplish this kind of processing is to use a parse tree
<em>traverser</em> as an <code>Input</code>, and a <em>constructor</em> of
some sort for an <code>Output</code>.  This avoids actually constructing nodes
or nodelists until they are really needed.  (Attribute lists, in particular,
will usually have to be constructed, but the attributes themselves can be
shared so the overhead is small.  Nodes in child lists <em>cannot</em> be
shared, but we use traversal to avoid constructing them in most cases.) <p>

The default action for a node is to copy it (recursively, if necessary) from
the current <code>Input</code> to the current <code>Output</code>.  Active
nodes have an <code>action</code> routine that performs any necessary
computation, and puts the results on the <code>Output</code>.

<h3>Local Transformations</h3>

Active nodes in the DPS all have the characteristic that they implement
<em>local</em> functions:  at most they will be replaced by a NodeList.<p>

If it can be determined at parse time that a node contains no children
with side effects, all the children of that node can be expanded in
parallel. <p> 

In any case, a document in which all active nodes are local can be processed
in a single depth-first, left-to-right traversal. 


<h2>Implementation: New</h2>

<h3>Structure Sharing and Copying</h3>

Because of the way the DOM works, with nodes linked to their parent and
siblings, it is essentially impossible to share structure.  If a node is part
of an existing document tree and needs to be added to a new one, it has to be
recursively copied.  This is inefficient, so the DPS only copies nodes when it
is actually building structure.<p>

The main exception to this at present is attribute lists -- these are
represented as instances of <code>ParseTreeAttrs</code>, which is essentially
an array.  Hence attributes can be shared.  Attribute <em>lists</em>, however,
have to be copied in order to prevent changes made to the attributes of one
element from being reflected in those of its copies.  Fortunately, attribute
lists are fairly light-weight.  <p>


<h3>Processing Algorithm</h3>

The fundamental implementation is to <em>traverse</em> an active document
(ParseTree) using a <code>ParseTreeIterator</code> or <code>Input</code> (An
<code>Input</code> is basically a specialized version of the DOM's
<code>TreeIterator</code> <em>except:</em>

<ul>
  <li> It may be unidirectional, implementing only the navigation operations
       <ul>
	 <li> <code>toNextSibling</code>
	 <li> <code>toParent</code>
	 <li> <code>toFirstChild</code>
       </ul>
  <li> Rather than directly returning the next Node, it is possible to
       <em>query</em> it to determine its node type, string data, and
       whether it has children or attributes.
  <li> If <code>input.hasChildren()</code> returns <code>true</code> but
       <code>input.getNode().hasChildren()</code> returns <code>false</code>,
       we know that <code><em>input</em></code> is a parser, and that
       the current node's children have not been seen yet.
  <li> The following all return implementations of ActiveNode:
       <ul>
	 <li> <code>getNode</code> -- a reference to the actual current node
	      in the parse tree.  It is possible that not all of its children
	      will be present.
	 <li> <code>getTree</code> -- a reference to the same object as
	      getNode, except that it is guaranteed that all of its children
	      are present. 
       </ul>
</ul>

(Note that <code>ParseTreeIterator</code> has been dropped from recent
versions of the DOM Level 1, but it's still a good idea.)<p>

Similarly, the output is constructed by means of an <code>Output</code>.  This
combines traversal with construction, so that it is possible to add a node to
the document under construction, then go on to add its children. <p>

This means that Output needs <code>startNode</code> and <code>endNode</code>
as well as <code>putNode</code> (which adds a complete subtree).  <p>

Note that a Parser requires its own stack in order to handle
<code>toNextSibling</code> and <code>toParent</code> when unprocessed children
remain.  This stack, though, can just be a simple List of pending tags.<p>

An action routine will normally obtain its ``arguments'' (i.e. the attributes
and children of the node that invoked it) by way of a suitable Output.  This
could then be returned to the action routine's calling context as a
continuation.  In any case, the Output is strongly typed, so the action
routine can obtain the relevant objects (e.g. ActiveElement, NodeList, etc.)
knowing their exact types.  This lets the <code>endAction</code> routine also
be strongly typed.<p>



<h3>Algorithms:</h3>

The basic main loop, without evaluation, is:
<ol>
  <li> Get a Node (input.toNextSibling)
  <li> Children?
       <dl>
	 <dt> yes:
	 <dd> output.startNode
	      <ol>
		<li> input.toFirstChild
		<li> (handle children)
		<li> input.toParent
	      </ol>
	      output.endNode
	 <dt> no:
	 <dd> output.putNode
       </dl>
</ol>

This can be done iteratively by just keeping track of nesting depth, although
it's probably simpler to do it recursively.<p>

If the input is a complete parse tree and the output doesn't need a clean
copy, it would be possible to short-circuit to <code>putNode</code> in both
cases.  But usually the output would just recurse through the children anyway!
So it's not necessary.<p>

The basic main loop for evaluation is:
<ol>
  <li> Get a Node
  <li> Children?
       <dl>
	 <dt> yes:
	 <dd> push Context / startAction
	      <ol>
		<li> input.toFirstChild
		<li> (handle children)
		<li> input.toParent
	      </ol>
	      pop Context / endAction
	 <dt> no:
	 <dd> nodeAction (default: put)
       </dl>
</ol>

If the endAction routine is going to need a parsed or expanded tree at this
point (and it usually will), all <code>startAction</code> has to do is create
an appropriate document fragment as output.  The neat thing is that it could
even be a StringBufferOutput if what it needs is the content as a String.<p>

There's a bit of a question whether one wants to do this recursively or
iteratively.  In this case, though, it's clear that one has to make a new
Context for the children in any case, so the only question is whether one
calls <code>newContext.run</code> or just pushes the context and keeps on
going.<p>

If a parse tree is needed, and it's going to be either expanded or discarded
(for example the content of a &lt;then&gt; or &lt;else&gt;), it would be
possible (and highly desirable) to avoid copying it.  This will require
additional thought, but it suggests that &lt;if&gt;'s startAction may need to
retain control instead of setting flags and returning back to the main
loop.  If we're using recursion to handle the children it's trivial. <p>

We can simplify this if <code>nodeAction</code> <em>calls</em>
<code>startAction</code>.  This gives us the recursive version trivially, and
simplifies short-circuiting.  Since the Context is pushed and popped inside
<code>nodeAction</code>, it's easy to avoid doing it.<p>



<h3>Additional notes:</h3>

Some advantages over the old approach:

<ul>
  <li> We no longer need ``syntax'' in <code>Token</code>; we just do the
       right thing on the way up the tree. 
  <li> We no longer need a ``passing'' flag, either:  we're always just
       passing nodes to an Output. 
  <li> All of the different places where one does expansions Or iterates over
       children (Util, Token, etc.) go away.  There may still be places where
       we want this, but it's basically a matter of creating a suitable
       Context and turning it loose.
</ul>



It will be very useful for ActiveNode itself to know whether or not it's
``new''; this may be as simple as checking for existance of a parent, which
will work for everything except Document.  A further complication is that
either the Processor has to inform its input when there's a change of Tagset,
or the Parser has to keep checking.  Uck.  Best to have a different parser
(InterFormParser) for this.  Note that it's always ok to add tags to the
document-level tagset. <p>


<h2>Implementation: Old</h2>

The fundamental implementation technique is to <em>traverse</em> the parse
tree, resulting in a stream of <code>Token</code> nodes.  A Token contains a
reference back to the original node, and a reference to a Handler that
contains all of the action information.  A single SGML Element gets turned
into <em>two</em> <code>Token</code>s:  one for the start tag, and one for the
end tag. <p> 

An <code>Input</code> is a source for <code>Token</code>s.  A
<code>Processor</code> takes <code>Token</code>s from an <code>Input</code>,
processes them (figures) by invoking methods on their <code>Handler</code>s,
and passes the results to an <code>Output</code>. <p>

Along the way, a <code>Processor</code> might build a parse tree out of, not
ordinary <code>Node</code>s, but <code>Token</code>s.  Unlike a
<code>Node</code>, a <code>Token</code> can be asked to expand itself.
<p>

There are several major problems with this approach:
<ol>
  <li> We'd like to build parse trees out of ordinary <code>Node</code>s, and
       in particular out of arbitrary implementations of the <code>Node</code>
       interface.  In doing this we gain the ability to associate intrinsic
       behavior with objects in the parse tree, but lose the ability to
       associate arbitrary handlers with them.  Testing each <code>Node</code>
       in the tree to find out whether it's a <code>Token</code> is potentially
       very inefficient. 
  <li> <code>Handler</code>s get complicated because we need to insure that
       they produce equivalent results when converting to a
       <code>String</code>, outputting characters to a stream, constructing a
       new parse tree, and modifying an old one in place.
</ol>

We have several possible remedies:

<ul>
  <li> Make every <code>Node</code> tell (via an <code>isToken</code> method)
       whether it's a <code>Token</code>, or (more efficiently) return a
       suitable <code>Handler</code> from <code>getHandler</code>.  This
       involves extending the DOM interfaces in possibly-incompatible ways.
  <li> Give every <code>Node</code> some of the appropriate
       <code>Handler</code> methods: <code>expand</code>, etc.  Much more
       effient, but does even more damage to the model.
  <li> Give <code>Token</code> a different (set of) node types.  This means
       that a <code>Token</code> has a different node type from the
       <code>Node</code> it represents, and still leaves us the inefficiency
       of casting <code>Node</code> to <code>Token</code> (which isn't free in
       Java).
  <li> Build parallel <code>Node</code> and <code>Token</code> trees.
       Inactive <code>Node</code>s can be treated as constants or as comments,
       whichever is more appropriate. 
</ul>

<hr>
<b>Copyright &copy; 1998 Ricoh Silicon Valley</b><br>
<b>$Id$</b><br>
<address><a href="http://rsv.ricoh.com/~steve/"
         >Stephen R. Savitzky</a> &lt;<a href="mailto:steve@rsv.ricoh.com"
         >steve@rsv.ricoh.com</a>&gt;</address>
</body></html>
