<!doctype html public "-//IETF//DTD HTML//EN//2.0">
<html><head>
<title>About the Document Processing System</title>
<link rev="made" href="mailto:steve@rsv.ricoh.com">
</head><body>
<h1>About the Document Processing System</h1>

<blockquote><em>
  This document contains notes about the PIA's Document Processing System
  (DPS), as implemented in the Java module <code>crc.dps</code>.
</em></blockquote>

<h2>Philosophy</h2>

The DPS has several ways of looking at a document:

<ul>
  <li> As a character stream
  <li> As a parse tree
  <li> As a program, which ``expands'' (evaluates) to a document.
</ul>

An InterForm could be viewed as an active document (program) which expands
into a character stream.  The easy way to implement an InterForm under this
view would be to use the <code>toString</code> method on <code>Node</code>.
Active nodes would simply expand appropriately by overriding the
<code>toString</code> method, and everything would be cool.  <p>

There are several problems with this:
<ol>
  <li> In some cases the InterForm is represented as a stream (file), and we
       want to expand it ``on the fly''.
  <li> In other cases, we want the result to be another parse tree.  The
       biggest problem here is that <code>Node</code> doesn't have an
       <code>eval</code> method.
  <li> In yet other cases, we want the result to be something else altogether,
       for example nothing (evaluation for side effects), a bitmap (rendering
       on the screen or for print), or a totally transformed document.
  <li> Sometimes we want to do all three:  expand into a stream, modify the
       original InterForm parse tree itself, and store the modified parse tree
       back into the original file.
  <li> What's worse, we want to be able to process the same document in
       different ways (e.g. expanding it or pretty-printing it).
</ol>

Instead, we prefer to view an InterForm as a ParseTree Document composed of
Nodes (some of) which implement the ActiveNode interface.  <em>Active</em>
nodes simply expand into more nodes (specifically,
<code><em>node</em>.expand(<em>context</em>)</code> yields a NodeList).


<h3>Local Transformations</h3>

Active nodes in the DPS all have the characteristic that they implement
<em>local</em> functions:  at most they will be replaced by a NodeList.<p>

If it can be determined at parse time that a node contains no children
with side effects, all the children of that node can be expanded in
parallel. <p> 

In any case, a document in which all active nodes are local can be processed
in a single depth-first, left-to-right traversal. 


<h2>Implementation: New</h2>

<h3>To Be Done</h3>

<ul>
  <li> One problem:  attributes don't have a next sibling.
       When we get to the end of a list we mustn't call advanceParser,
       so we need a flag that says whether we're in a list.  Could be done by
       depth, but a flag might be easier.

  <li> Need flag that tells whether the current node has been processed yet.
       (really relevant only for toNextNode, to keep track of whether we've
       enumerated the children yet)

  <li> Context needs getEntityValue, getIndexValue

  <li> ParseTreeElement should keep information about whether any of its
       attributes contain entities that need to be expanded.  Should be much
       faster, since most don't and it's known at parse time. <p>

       The other possibility is lazy evaluation -- don't even look at them
       until they're needed when converting an attribute's value to a string.<p>

  <li> We will want a ParseTreeIterator that implements both Input and
       Output (and of course TreeIterator).  The main use would be
       constructing an node and then processing it.

  <li> The processor context stack is a linked list of contexts, built as
       needed by recursion.  It is isomorphic to the actor invocation stack,
       i.e. it only contains <em>relevant</em> nodes.  It should <em>not</em>
       implement Cursor -- it should have input, output, and entities
       <em>only</em>.  At any given time it can get the current node from
       the <code>input</code>, in the most useful form!  Therefore, Context
       should not extend Cursor. 

  <li> The parser might be simplified by adding an auxiliary node type for end
       tags (for use in <code>next</code>).  Alternatively could simply have
       an additional flag (atLast) and state: <code>currentEndTag</code>.  The
       latter requires more hacking in the parser, but is clearly the
       <em>Right Thing<sup>TM</sup></em>.

  <li> Tagset needs to be (effectively) a DOMFactory for <em>parse trees</em>. 

  <li> Rename ParseTree* -&gt; Tree*  (A*??) and move to a separate subdir (?)

  <li> Eventually there should be a ParseTreeGenericNode, basically Token, so
       that we can build trees with arbitrary node types.  

  <li> The various stack and other auxiliary types should get moved into aux
       or eliminated altogether.  (later)

  <li> Want an interface for peering back up the nested elements to
       see what we're in.  Possibly just add to Cursor, since any
       implementation has a stack or a tree available.  A little lighter than
       Context, since it doesn't have bindings.

  <li> We probably need a Continuation interface as well as a Context.
       It is probably possible for an ActiveNode to function as a
       Continuation as well as, perhaps, a Handler.  Action may do.

  <li> It seems reasonable that the Context stack should <em>not</em> be
       identical to <em>either</em> the Input parse stack nor the Output
       construction stack: it should instead be the <em>actor invocation
       stack</em>.  

  <li> ... This makes it fairly  clear what needs to be added to make a
       Context.  Entities, at least.  Bindings could be passed down the eval
       stack along with in and out, so a full-bore context might not be needed
       at all.  (All three need to be in the processing stack, though, if we
       want an iterative processor.)

  <li> It's not impossible that a Processor might be functional as both an
       Input and an Output, so it might be able to do process-in-place.

  <li> Alternatively, some way of attaching processing information to either
       the Input or Output might work.
</ul>

<h3>Description</h3>

The fundamental implementation is to <em>traverse</em> an active document
(ParseTree) using a <code>ParseTreeIterator</code> or <code>Input</code> (An
<code>Input</code> is basically a specialized version of the DOM's
<code>TreeIterator</code> <em>except:</em>

<ul>
  <li> It may be unidirectional, implementing only the navigation operations
       <ul>
	 <li> <code>toNextSibling</code>
	 <li> <code>toParent</code> -- unlike a TreeIterator, a
	      ParseTreeIterator actually has <em>two</em> possible
	      ``positions'' relative to a Node:  before it and after it.
	 <li> <code>toFirstChild</code>
	 <li> <code>toFirstAttribute</code> (?)
       </ul>
  <li> Rather than directly returning the next Node, it is possible to
       <em>query</em> it to determine its node type, string data, and
       whether it has children or attributes.
  <li> The following all return implementations of ActiveNode:
       <ul>
	 <li> <code>getNode</code> -- a reference to the actual current node
	      in the parse tree.  It is possible that not all of its children
	      will be present.
	 <li> <code>getTree</code> -- a reference to the same object as
	      getNode, except that it is guaranteed that all of its children
	      are present. 
       </ul>
</ul>

Similarly, the output is constructed by means of an <code>Output</code>.  This
combines traversal with construction, so that it is possible to add a node to
the document under construction, then go on to add its children. <p>

This means that Output needs <code>startNode</code> and <code>endNode</code>
as well as <code>putNode</code> (which adds a complete subtree).  <p>

Note that a Parser requires its own stack in order to handle
<code>toNextSibling</code> and <code>toParent</code> when unprocessed children
remain.  This stack, though, can just be a simple List of pending tags.<p>

An action routine will normally obtain its ``arguments'' (i.e. the attributes
and children of the node that invoked it) by way of a suitable Output.  This
could then be returned to the action routine's calling context as a
continuation.  In any case, the Output is strongly typed, so the action
routine can obtain the relevant objects (e.g. ActiveElement, NodeList, etc.)
knowing their exact types.  This lets the <code>endAction</code> routine also
be strongly typed.<p>



<h3>Algorithms:</h3>

The basic main loop, without evaluation, is:
<ol>
  <li> Get a Node (input.toNextSibling)
  <li> Children?
       <dl>
	 <dt> yes:
	 <dd> output.startNode
	      <ol>
		<li> input.toFirstChild
		<li> (handle children)
		<li> input.toParent
	      </ol>
	      output.endNode
	 <dt> no:
	 <dd> output.putNode
       </dl>
</ol>

This can be done iteratively by just keeping track of nesting depth, although
it's probably simpler to do it recursively.<p>

If the input is a complete parse tree and the output doesn't need a clean
copy, it would be possible to short-circuit to <code>putNode</code> in both
cases.  But usually the output would just recurse through the children anyway!
So it's not necessary.<p>

The basic main loop for evaluation is:
<ol>
  <li> Get a Node
  <li> Children?
       <dl>
	 <dt> yes:
	 <dd> push Context / startAction
	      <ol>
		<li> input.toFirstChild
		<li> (handle children)
		<li> input.toParent
	      </ol>
	      pop Context / endAction
	 <dt> no:
	 <dd> nodeAction (default: put)
       </dl>
</ol>

If the endAction routine is going to need a parsed or expanded tree at this
point (and it usually will), all <code>startAction</code> has to do is create
an appropriate document fragment as output.  The neat thing is that it could
even be a StringBufferOutput if what it needs is the content as a String.<p>

There's a bit of a question whether one wants to do this recursively or
iteratively.  In this case, though, it's clear that one has to make a new
Context for the children in any case, so the only question is whether one
calls <code>newContext.run</code> or just pushes the context and keeps on
going.<p>

If a parse tree is needed, and it's going to be either expanded or discarded
(for example the content of a &lt;then&gt; or &lt;else&gt;), it would be
possible (and highly desirable) to avoid copying it.  This will require
additional thought, but it suggests that &lt;if&gt;'s startAction may need to
retain control instead of setting flags and returning back to the main
loop.  If we're using recursion to handle the children it's trivial. <p>

We can simplify this if <code>nodeAction</code> <em>calls</em>
<code>startAction</code>.  This gives us the recursive version trivially, and
simplifies short-circuiting.  Since the Context is pushed and popped inside
<code>nodeAction</code>, it's easy to avoid doing it.<p>



<h3>Additional notes:</h3>

Some advantages over the old approach:

<ul>
  <li> We no longer need ``syntax'' in <code>Token</code>; we just do the
       right thing on the way up the tree. 
  <li> We no longer need a ``passing'' flag, either:  we're always just
       passing nodes to an Output. 
  <li> All of the different places where one does expansions or iterates over
       children (Util, Token, etc.) go away.  There may still be places where
       we want this, but it's basically a matter of creating a suitable
       Context and turning it loose.
</ul>



It will be very useful for ActiveNode itself to know whether or not it's
``new''; this may be as simple as checking for existance of a parent, which
will work for everything except Document.  A further complication is that
either the Processor has to inform its input when there's a change of Tagset,
or the Parser has to keep checking.  Uck.  Best to have a different parser
(InterFormParser) for this.  Note that it's always ok to add tags to the
document-level tagset. <p>


<h2>Implementation: Old</h2>

The fundamental implementation technique is to <em>traverse</em> the parse
tree, resulting in a stream of <code>Token</code> nodes.  A Token contains a
reference back to the original node, and a reference to a Handler that
contains all of the action information.  A single SGML Element gets turned
into <em>two</em> <code>Token</code>s:  one for the start tag, and one for the
end tag. <p> 

An <code>Input</code> is a source for <code>Token</code>s.  A
<code>Processor</code> takes <code>Token</code>s from an <code>Input</code>,
processes them (figures) by invoking methods on their <code>Handler</code>s,
and passes the results to an <code>Output</code>. <p>

Along the way, a <code>Processor</code> might build a parse tree out of, not
ordinary <code>Node</code>s, but <code>Token</code>s.  Unlike a
<code>Node</code>, a <code>Token</code> can be asked to expand itself.
<p>

There are several major problems with this approach:
<ol>
  <li> We'd like to build parse trees out of ordinary <code>Node</code>s, and
       in particular out of arbitrary implementations of the <code>Node</code>
       interface.  In doing this we gain the ability to associate intrinsic
       behavior with objects in the parse tree, but lose the ability to
       associate arbitrary handlers with them.  Testing each <code>Node</code>
       in the tree to find out whether it's a <code>Token</code> is potentially
       very inefficient. 
  <li> <code>Handler</code>s get complicated because we need to insure that
       they produce equivalent results when converting to a
       <code>String</code>, outputting characters to a stream, constructing a
       new parse tree, and modifying an old one in place.
</ol>

We have several possible remedies:

<ul>
  <li> Make every <code>Node</code> tell (via an <code>isToken</code> method)
       whether it's a <code>Token</code>, or (more efficiently) return a
       suitable <code>Handler</code> from <code>getHandler</code>.  This
       involves extending the DOM interfaces in possibly-incompatible ways.
  <li> Give every <code>Node</code> some of the appropriate
       <code>Handler</code> methods: <code>expand</code>, etc.  Much more
       effient, but does even more damage to the model.
  <li> Give <code>Token</code> a different (set of) node types.  This means
       that a <code>Token</code> has a different node type from the
       <code>Node</code> it represents, and still leaves us the inefficiency
       of casting <code>Node</code> to <code>Token</code> (which isn't free in
       Java).
  <li> Build parallel <code>Node</code> and <code>Token</code> trees.
       Inactive <code>Node</code>s can be treated as constants or as comments,
       whichever is more appropriate. 
</ul>

<hr>
<b>Copyright &copy; 1998 Ricoh Silicon Valley</b><br>
<b>$Id$</b><br>
<address><a href="http://rsv.ricoh.com/~steve/"
         >Stephen R. Savitzky</a> &lt;<a href="mailto:steve@rsv.ricoh.com"
         >steve@rsv.ricoh.com</a>&gt;</address>
</body></html>
